/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key2) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key2, result);
  return result;
};

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "node_modules/reflect-metadata/Reflect.js"() {
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root2 = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
        var exporter = makeExporter(Reflect3);
        if (typeof root2.Reflect !== "undefined") {
          exporter = makeExporter(root2.Reflect, exporter);
        }
        factory(exporter, root2);
        if (typeof root2.Reflect === "undefined") {
          root2.Reflect = Reflect3;
        }
        function makeExporter(target, previous) {
          return function(key2, value) {
            Object.defineProperty(target, key2, { configurable: true, writable: true, value });
            if (previous)
              previous(key2, value);
          };
        }
        function functionThis() {
          try {
            return Function("return this;")();
          } catch (_) {
          }
        }
        function indirectEvalThis() {
          try {
            return (void 0, eval)("(function() { return this; })()");
          } catch (_) {
          }
        }
        function sloppyModeThis() {
          return functionThis() || indirectEvalThis();
        }
      })(function(exporter, root2) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          // create an object in dictionary mode (a.k.a. "slow" mode in v8)
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map, key2) {
            return hasOwn.call(map, key2);
          } : function(map, key2) {
            return key2 in map;
          },
          get: downLevel ? function(map, key2) {
            return hasOwn.call(map, key2) ? map[key2] : void 0;
          } : function(map, key2) {
            return map[key2];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
        var metadataRegistry = GetOrCreateMetadataRegistry();
        var metadataProvider = CreateMetadataProvider(metadataRegistry);
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var provider = GetMetadataProvider(
            target,
            propertyKey,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return;
          return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            true
          );
          provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
        }
        function OrdinaryMetadataKeys(O, P) {
          var ownKeys = OrdinaryOwnMetadataKeys(O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (parent === null)
            return ownKeys;
          var parentKeys = OrdinaryMetadataKeys(parent, P);
          if (parentKeys.length <= 0)
            return ownKeys;
          if (ownKeys.length <= 0)
            return parentKeys;
          var set2 = new _Set();
          var keys2 = [];
          for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key2 = ownKeys_1[_i];
            var hasKey = set2.has(key2);
            if (!hasKey) {
              set2.add(key2);
              keys2.push(key2);
            }
          }
          for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key2 = parentKeys_1[_a];
            var hasKey = set2.has(key2);
            if (!hasKey) {
              set2.add(key2);
              keys2.push(key2);
            }
          }
          return keys2;
        }
        function OrdinaryOwnMetadataKeys(O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*create*/
            false
          );
          if (!provider) {
            return [];
          }
          return provider.OrdinaryOwnMetadataKeys(O, P);
        }
        function Type(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return x === void 0;
        }
        function IsNull(x) {
          return x === null;
        }
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        function IsObject(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
              throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
          if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              var result = toString_1.call(O);
              if (!IsObject(result))
                return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
          } else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              var result = toString_2.call(O);
              if (!IsObject(result))
                return result;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key2 = ToPrimitive(
            argument,
            3
            /* String */
          );
          if (IsSymbol(key2))
            return key2;
          return ToString(key2);
        }
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function SameValueZero(x, y) {
          return x === y || x !== x && y !== y;
        }
        function GetMethod(V, P) {
          var func = V[P];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result = iterator.next();
          return result.done ? false : result;
        }
        function IteratorClose(iterator) {
          var f = iterator["return"];
          if (f)
            f.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O) {
          var proto = Object.getPrototypeOf(O);
          if (typeof O !== "function" || O === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O)
            return proto;
          return constructor;
        }
        function CreateMetadataRegistry() {
          var fallback;
          if (!IsUndefined(registrySymbol) && typeof root2.Reflect !== "undefined" && !(registrySymbol in root2.Reflect) && typeof root2.Reflect.defineMetadata === "function") {
            fallback = CreateFallbackProvider(root2.Reflect);
          }
          var first;
          var second;
          var rest;
          var targetProviderMap = new _WeakMap();
          var registry = {
            registerProvider,
            getProvider,
            setProvider
          };
          return registry;
          function registerProvider(provider) {
            if (!Object.isExtensible(registry)) {
              throw new Error("Cannot add provider to a frozen registry.");
            }
            switch (true) {
              case fallback === provider:
                break;
              case IsUndefined(first):
                first = provider;
                break;
              case first === provider:
                break;
              case IsUndefined(second):
                second = provider;
                break;
              case second === provider:
                break;
              default:
                if (rest === void 0)
                  rest = new _Set();
                rest.add(provider);
                break;
            }
          }
          function getProviderNoCache(O, P) {
            if (!IsUndefined(first)) {
              if (first.isProviderFor(O, P))
                return first;
              if (!IsUndefined(second)) {
                if (second.isProviderFor(O, P))
                  return first;
                if (!IsUndefined(rest)) {
                  var iterator = GetIterator(rest);
                  while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                      return void 0;
                    }
                    var provider = IteratorValue(next);
                    if (provider.isProviderFor(O, P)) {
                      IteratorClose(iterator);
                      return provider;
                    }
                  }
                }
              }
            }
            if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
              return fallback;
            }
            return void 0;
          }
          function getProvider(O, P) {
            var providerMap = targetProviderMap.get(O);
            var provider;
            if (!IsUndefined(providerMap)) {
              provider = providerMap.get(P);
            }
            if (!IsUndefined(provider)) {
              return provider;
            }
            provider = getProviderNoCache(O, P);
            if (!IsUndefined(provider)) {
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O, providerMap);
              }
              providerMap.set(P, provider);
            }
            return provider;
          }
          function hasProvider(provider) {
            if (IsUndefined(provider))
              throw new TypeError();
            return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
          }
          function setProvider(O, P, provider) {
            if (!hasProvider(provider)) {
              throw new Error("Metadata provider not registered.");
            }
            var existingProvider = getProvider(O, P);
            if (existingProvider !== provider) {
              if (!IsUndefined(existingProvider)) {
                return false;
              }
              var providerMap = targetProviderMap.get(O);
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O, providerMap);
              }
              providerMap.set(P, provider);
            }
            return true;
          }
        }
        function GetOrCreateMetadataRegistry() {
          var metadataRegistry2;
          if (!IsUndefined(registrySymbol) && IsObject(root2.Reflect) && Object.isExtensible(root2.Reflect)) {
            metadataRegistry2 = root2.Reflect[registrySymbol];
          }
          if (IsUndefined(metadataRegistry2)) {
            metadataRegistry2 = CreateMetadataRegistry();
          }
          if (!IsUndefined(registrySymbol) && IsObject(root2.Reflect) && Object.isExtensible(root2.Reflect)) {
            Object.defineProperty(root2.Reflect, registrySymbol, {
              enumerable: false,
              configurable: false,
              writable: false,
              value: metadataRegistry2
            });
          }
          return metadataRegistry2;
        }
        function CreateMetadataProvider(registry) {
          var metadata2 = new _WeakMap();
          var provider = {
            isProviderFor: function(O, P) {
              var targetMetadata = metadata2.get(O);
              if (IsUndefined(targetMetadata))
                return false;
              return targetMetadata.has(P);
            },
            OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
            OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
            OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
            OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
            OrdinaryDeleteMetadata
          };
          metadataRegistry.registerProvider(provider);
          return provider;
          function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = metadata2.get(O);
            var createdTargetMetadata = false;
            if (IsUndefined(targetMetadata)) {
              if (!Create)
                return void 0;
              targetMetadata = new _Map();
              metadata2.set(O, targetMetadata);
              createdTargetMetadata = true;
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
              if (!Create)
                return void 0;
              metadataMap = new _Map();
              targetMetadata.set(P, metadataMap);
              if (!registry.setProvider(O, P, provider)) {
                targetMetadata.delete(P);
                if (createdTargetMetadata) {
                  metadata2.delete(O);
                }
                throw new Error("Wrong provider for target.");
              }
            }
            return metadataMap;
          }
          function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            return ToBoolean(metadataMap.has(MetadataKey));
          }
          function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return void 0;
            return metadataMap.get(MetadataKey);
          }
          function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              true
            );
            metadataMap.set(MetadataKey, MetadataValue);
          }
          function OrdinaryOwnMetadataKeys2(O, P) {
            var keys2 = [];
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return keys2;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
              var next = IteratorStep(iterator);
              if (!next) {
                keys2.length = k;
                return keys2;
              }
              var nextValue = IteratorValue(next);
              try {
                keys2[k] = nextValue;
              } catch (e) {
                try {
                  IteratorClose(iterator);
                } finally {
                  throw e;
                }
              }
              k++;
            }
          }
          function OrdinaryDeleteMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            if (!metadataMap.delete(MetadataKey))
              return false;
            if (metadataMap.size === 0) {
              var targetMetadata = metadata2.get(O);
              if (!IsUndefined(targetMetadata)) {
                targetMetadata.delete(P);
                if (targetMetadata.size === 0) {
                  metadata2.delete(targetMetadata);
                }
              }
            }
            return true;
          }
        }
        function CreateFallbackProvider(reflect) {
          var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
          var metadataOwner = new _WeakMap();
          var provider = {
            isProviderFor: function(O, P) {
              var metadataPropertySet = metadataOwner.get(O);
              if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
                return true;
              }
              if (getOwnMetadataKeys2(O, P).length) {
                if (IsUndefined(metadataPropertySet)) {
                  metadataPropertySet = new _Set();
                  metadataOwner.set(O, metadataPropertySet);
                }
                metadataPropertySet.add(P);
                return true;
              }
              return false;
            },
            OrdinaryDefineOwnMetadata: defineMetadata2,
            OrdinaryHasOwnMetadata: hasOwnMetadata2,
            OrdinaryGetOwnMetadata: getOwnMetadata2,
            OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
            OrdinaryDeleteMetadata: deleteMetadata2
          };
          return provider;
        }
        function GetMetadataProvider(O, P, Create) {
          var registeredProvider = metadataRegistry.getProvider(O, P);
          if (!IsUndefined(registeredProvider)) {
            return registeredProvider;
          }
          if (Create) {
            if (metadataRegistry.setProvider(O, P, metadataProvider)) {
              return metadataProvider;
            }
            throw new Error("Illegal state.");
          }
          return void 0;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = (
            /** @class */
            function() {
              function MapIterator2(keys2, values, selector) {
                this._index = 0;
                this._keys = keys2;
                this._values = values;
                this._selector = selector;
              }
              MapIterator2.prototype["@@iterator"] = function() {
                return this;
              };
              MapIterator2.prototype[iteratorSymbol] = function() {
                return this;
              };
              MapIterator2.prototype.next = function() {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                  var result = this._selector(this._keys[index], this._values[index]);
                  if (index + 1 >= this._keys.length) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  } else {
                    this._index++;
                  }
                  return { value: result, done: false };
                }
                return { value: void 0, done: true };
              };
              MapIterator2.prototype.throw = function(error) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                throw error;
              };
              MapIterator2.prototype.return = function(value) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                return { value, done: true };
              };
              return MapIterator2;
            }()
          );
          var Map3 = (
            /** @class */
            function() {
              function Map4() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              Object.defineProperty(Map4.prototype, "size", {
                get: function() {
                  return this._keys.length;
                },
                enumerable: true,
                configurable: true
              });
              Map4.prototype.has = function(key2) {
                return this._find(
                  key2,
                  /*insert*/
                  false
                ) >= 0;
              };
              Map4.prototype.get = function(key2) {
                var index = this._find(
                  key2,
                  /*insert*/
                  false
                );
                return index >= 0 ? this._values[index] : void 0;
              };
              Map4.prototype.set = function(key2, value) {
                var index = this._find(
                  key2,
                  /*insert*/
                  true
                );
                this._values[index] = value;
                return this;
              };
              Map4.prototype.delete = function(key2) {
                var index = this._find(
                  key2,
                  /*insert*/
                  false
                );
                if (index >= 0) {
                  var size = this._keys.length;
                  for (var i = index + 1; i < size; i++) {
                    this._keys[i - 1] = this._keys[i];
                    this._values[i - 1] = this._values[i];
                  }
                  this._keys.length--;
                  this._values.length--;
                  if (SameValueZero(key2, this._cacheKey)) {
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  return true;
                }
                return false;
              };
              Map4.prototype.clear = function() {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              };
              Map4.prototype.keys = function() {
                return new MapIterator(this._keys, this._values, getKey);
              };
              Map4.prototype.values = function() {
                return new MapIterator(this._keys, this._values, getValue2);
              };
              Map4.prototype.entries = function() {
                return new MapIterator(this._keys, this._values, getEntry);
              };
              Map4.prototype["@@iterator"] = function() {
                return this.entries();
              };
              Map4.prototype[iteratorSymbol] = function() {
                return this.entries();
              };
              Map4.prototype._find = function(key2, insert) {
                if (!SameValueZero(this._cacheKey, key2)) {
                  this._cacheIndex = -1;
                  for (var i = 0; i < this._keys.length; i++) {
                    if (SameValueZero(this._keys[i], key2)) {
                      this._cacheIndex = i;
                      break;
                    }
                  }
                }
                if (this._cacheIndex < 0 && insert) {
                  this._cacheIndex = this._keys.length;
                  this._keys.push(key2);
                  this._values.push(void 0);
                }
                return this._cacheIndex;
              };
              return Map4;
            }()
          );
          return Map3;
          function getKey(key2, _) {
            return key2;
          }
          function getValue2(_, value) {
            return value;
          }
          function getEntry(key2, value) {
            return [key2, value];
          }
        }
        function CreateSetPolyfill() {
          var Set3 = (
            /** @class */
            function() {
              function Set4() {
                this._map = new _Map();
              }
              Object.defineProperty(Set4.prototype, "size", {
                get: function() {
                  return this._map.size;
                },
                enumerable: true,
                configurable: true
              });
              Set4.prototype.has = function(value) {
                return this._map.has(value);
              };
              Set4.prototype.add = function(value) {
                return this._map.set(value, value), this;
              };
              Set4.prototype.delete = function(value) {
                return this._map.delete(value);
              };
              Set4.prototype.clear = function() {
                this._map.clear();
              };
              Set4.prototype.keys = function() {
                return this._map.keys();
              };
              Set4.prototype.values = function() {
                return this._map.keys();
              };
              Set4.prototype.entries = function() {
                return this._map.entries();
              };
              Set4.prototype["@@iterator"] = function() {
                return this.keys();
              };
              Set4.prototype[iteratorSymbol] = function() {
                return this.keys();
              };
              return Set4;
            }()
          );
          return Set3;
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys2 = HashMap.create();
          var rootKey = CreateUniqueKey();
          return (
            /** @class */
            function() {
              function WeakMap3() {
                this._key = CreateUniqueKey();
              }
              WeakMap3.prototype.has = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.has(table, this._key) : false;
              };
              WeakMap3.prototype.get = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.get(table, this._key) : void 0;
              };
              WeakMap3.prototype.set = function(target, value) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  true
                );
                table[this._key] = value;
                return this;
              };
              WeakMap3.prototype.delete = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? delete table[this._key] : false;
              };
              WeakMap3.prototype.clear = function() {
                this._key = CreateUniqueKey();
              };
              return WeakMap3;
            }()
          );
          function CreateUniqueKey() {
            var key2;
            do
              key2 = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys2, key2));
            keys2[key2] = true;
            return key2;
          }
          function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
              buffer[i] = Math.random() * 255 | 0;
            return buffer;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              var array = new Uint8Array(size);
              if (typeof crypto !== "undefined") {
                crypto.getRandomValues(array);
              } else if (typeof msCrypto !== "undefined") {
                msCrypto.getRandomValues(array);
              } else {
                FillRandomBytes(array, size);
              }
              return array;
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result += "-";
              if (byte < 16)
                result += "0";
              result += byte.toString(16).toLowerCase();
            }
            return result;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// node_modules/hogan.js/lib/compiler.js
var require_compiler = __commonJS({
  "node_modules/hogan.js/lib/compiler.js"(exports2) {
    (function(Hogan4) {
      var rIsWhitespace = /\S/, rQuot = /\"/g, rNewline = /\n/g, rCr = /\r/g, rSlash = /\\/g, rLineSep = /\u2028/, rParagraphSep = /\u2029/;
      Hogan4.tags = {
        "#": 1,
        "^": 2,
        "<": 3,
        "$": 4,
        "/": 5,
        "!": 6,
        ">": 7,
        "=": 8,
        "_v": 9,
        "{": 10,
        "&": 11,
        "_t": 12
      };
      Hogan4.scan = function scan(text, delimiters) {
        var len = text.length, IN_TEXT = 0, IN_TAG_TYPE = 1, IN_TAG = 2, state = IN_TEXT, tagType = null, tag = null, buf = "", tokens = [], seenTag = false, i = 0, lineStart = 0, otag = "{{", ctag = "}}";
        function addBuf() {
          if (buf.length > 0) {
            tokens.push({ tag: "_t", text: new String(buf) });
            buf = "";
          }
        }
        function lineIsWhitespace() {
          var isAllWhitespace = true;
          for (var j = lineStart; j < tokens.length; j++) {
            isAllWhitespace = Hogan4.tags[tokens[j].tag] < Hogan4.tags["_v"] || tokens[j].tag == "_t" && tokens[j].text.match(rIsWhitespace) === null;
            if (!isAllWhitespace) {
              return false;
            }
          }
          return isAllWhitespace;
        }
        function filterLine(haveSeenTag, noNewLine) {
          addBuf();
          if (haveSeenTag && lineIsWhitespace()) {
            for (var j = lineStart, next; j < tokens.length; j++) {
              if (tokens[j].text) {
                if ((next = tokens[j + 1]) && next.tag == ">") {
                  next.indent = tokens[j].text.toString();
                }
                tokens.splice(j, 1);
              }
            }
          } else if (!noNewLine) {
            tokens.push({ tag: "\n" });
          }
          seenTag = false;
          lineStart = tokens.length;
        }
        function changeDelimiters(text2, index) {
          var close = "=" + ctag, closeIndex = text2.indexOf(close, index), delimiters2 = trim(
            text2.substring(text2.indexOf("=", index) + 1, closeIndex)
          ).split(" ");
          otag = delimiters2[0];
          ctag = delimiters2[delimiters2.length - 1];
          return closeIndex + close.length - 1;
        }
        if (delimiters) {
          delimiters = delimiters.split(" ");
          otag = delimiters[0];
          ctag = delimiters[1];
        }
        for (i = 0; i < len; i++) {
          if (state == IN_TEXT) {
            if (tagChange(otag, text, i)) {
              --i;
              addBuf();
              state = IN_TAG_TYPE;
            } else {
              if (text.charAt(i) == "\n") {
                filterLine(seenTag);
              } else {
                buf += text.charAt(i);
              }
            }
          } else if (state == IN_TAG_TYPE) {
            i += otag.length - 1;
            tag = Hogan4.tags[text.charAt(i + 1)];
            tagType = tag ? text.charAt(i + 1) : "_v";
            if (tagType == "=") {
              i = changeDelimiters(text, i);
              state = IN_TEXT;
            } else {
              if (tag) {
                i++;
              }
              state = IN_TAG;
            }
            seenTag = i;
          } else {
            if (tagChange(ctag, text, i)) {
              tokens.push({
                tag: tagType,
                n: trim(buf),
                otag,
                ctag,
                i: tagType == "/" ? seenTag - otag.length : i + ctag.length
              });
              buf = "";
              i += ctag.length - 1;
              state = IN_TEXT;
              if (tagType == "{") {
                if (ctag == "}}") {
                  i++;
                } else {
                  cleanTripleStache(tokens[tokens.length - 1]);
                }
              }
            } else {
              buf += text.charAt(i);
            }
          }
        }
        filterLine(seenTag, true);
        return tokens;
      };
      function cleanTripleStache(token) {
        if (token.n.substr(token.n.length - 1) === "}") {
          token.n = token.n.substring(0, token.n.length - 1);
        }
      }
      function trim(s) {
        if (s.trim) {
          return s.trim();
        }
        return s.replace(/^\s*|\s*$/g, "");
      }
      function tagChange(tag, text, index) {
        if (text.charAt(index) != tag.charAt(0)) {
          return false;
        }
        for (var i = 1, l = tag.length; i < l; i++) {
          if (text.charAt(index + i) != tag.charAt(i)) {
            return false;
          }
        }
        return true;
      }
      var allowedInSuper = { "_t": true, "\n": true, "$": true, "/": true };
      function buildTree(tokens, kind, stack, customTags) {
        var instructions = [], opener = null, tail = null, token = null;
        tail = stack[stack.length - 1];
        while (tokens.length > 0) {
          token = tokens.shift();
          if (tail && tail.tag == "<" && !(token.tag in allowedInSuper)) {
            throw new Error("Illegal content in < super tag.");
          }
          if (Hogan4.tags[token.tag] <= Hogan4.tags["$"] || isOpener(token, customTags)) {
            stack.push(token);
            token.nodes = buildTree(tokens, token.tag, stack, customTags);
          } else if (token.tag == "/") {
            if (stack.length === 0) {
              throw new Error("Closing tag without opener: /" + token.n);
            }
            opener = stack.pop();
            if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
              throw new Error("Nesting error: " + opener.n + " vs. " + token.n);
            }
            opener.end = token.i;
            return instructions;
          } else if (token.tag == "\n") {
            token.last = tokens.length == 0 || tokens[0].tag == "\n";
          }
          instructions.push(token);
        }
        if (stack.length > 0) {
          throw new Error("missing closing tag: " + stack.pop().n);
        }
        return instructions;
      }
      function isOpener(token, tags) {
        for (var i = 0, l = tags.length; i < l; i++) {
          if (tags[i].o == token.n) {
            token.tag = "#";
            return true;
          }
        }
      }
      function isCloser(close, open, tags) {
        for (var i = 0, l = tags.length; i < l; i++) {
          if (tags[i].c == close && tags[i].o == open) {
            return true;
          }
        }
      }
      function stringifySubstitutions(obj) {
        var items = [];
        for (var key2 in obj) {
          items.push('"' + esc(key2) + '": function(c,p,t,i) {' + obj[key2] + "}");
        }
        return "{ " + items.join(",") + " }";
      }
      function stringifyPartials(codeObj) {
        var partials = [];
        for (var key2 in codeObj.partials) {
          partials.push('"' + esc(key2) + '":{name:"' + esc(codeObj.partials[key2].name) + '", ' + stringifyPartials(codeObj.partials[key2]) + "}");
        }
        return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
      }
      Hogan4.stringify = function(codeObj, text, options) {
        return "{code: function (c,p,i) { " + Hogan4.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) + "}";
      };
      var serialNo = 0;
      Hogan4.generate = function(tree, text, options) {
        serialNo = 0;
        var context = { code: "", subs: {}, partials: {} };
        Hogan4.walk(tree, context);
        if (options.asString) {
          return this.stringify(context, text, options);
        }
        return this.makeTemplate(context, text, options);
      };
      Hogan4.wrapMain = function(code) {
        return 'var t=this;t.b(i=i||"");' + code + "return t.fl();";
      };
      Hogan4.template = Hogan4.Template;
      Hogan4.makeTemplate = function(codeObj, text, options) {
        var template = this.makePartials(codeObj);
        template.code = new Function("c", "p", "i", this.wrapMain(codeObj.code));
        return new this.template(template, text, this, options);
      };
      Hogan4.makePartials = function(codeObj) {
        var key2, template = { subs: {}, partials: codeObj.partials, name: codeObj.name };
        for (key2 in template.partials) {
          template.partials[key2] = this.makePartials(template.partials[key2]);
        }
        for (key2 in codeObj.subs) {
          template.subs[key2] = new Function("c", "p", "t", "i", codeObj.subs[key2]);
        }
        return template;
      };
      function esc(s) {
        return s.replace(rSlash, "\\\\").replace(rQuot, '\\"').replace(rNewline, "\\n").replace(rCr, "\\r").replace(rLineSep, "\\u2028").replace(rParagraphSep, "\\u2029");
      }
      function chooseMethod(s) {
        return ~s.indexOf(".") ? "d" : "f";
      }
      function createPartial(node, context) {
        var prefix = "<" + (context.prefix || "");
        var sym = prefix + node.n + serialNo++;
        context.partials[sym] = { name: node.n, partials: {} };
        context.code += 't.b(t.rp("' + esc(sym) + '",c,p,"' + (node.indent || "") + '"));';
        return sym;
      }
      Hogan4.codegen = {
        "#": function(node, context) {
          context.code += "if(t.s(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,0,' + node.i + "," + node.end + ',"' + node.otag + " " + node.ctag + '")){t.rs(c,p,function(c,p,t){';
          Hogan4.walk(node.nodes, context);
          context.code += "});c.pop();}";
        },
        "^": function(node, context) {
          context.code += "if(!t.s(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
          Hogan4.walk(node.nodes, context);
          context.code += "};";
        },
        ">": createPartial,
        "<": function(node, context) {
          var ctx = { partials: {}, code: "", subs: {}, inPartial: true };
          Hogan4.walk(node.nodes, ctx);
          var template = context.partials[createPartial(node, context)];
          template.subs = ctx.subs;
          template.partials = ctx.partials;
        },
        "$": function(node, context) {
          var ctx = { subs: {}, code: "", partials: context.partials, prefix: node.n };
          Hogan4.walk(node.nodes, ctx);
          context.subs[node.n] = ctx.code;
          if (!context.inPartial) {
            context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
          }
        },
        "\n": function(node, context) {
          context.code += write('"\\n"' + (node.last ? "" : " + i"));
        },
        "_v": function(node, context) {
          context.code += "t.b(t.v(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
        },
        "_t": function(node, context) {
          context.code += write('"' + esc(node.text) + '"');
        },
        "{": tripleStache,
        "&": tripleStache
      };
      function tripleStache(node, context) {
        context.code += "t.b(t.t(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
      }
      function write(s) {
        return "t.b(" + s + ");";
      }
      Hogan4.walk = function(nodelist, context) {
        var func;
        for (var i = 0, l = nodelist.length; i < l; i++) {
          func = Hogan4.codegen[nodelist[i].tag];
          func && func(nodelist[i], context);
        }
        return context;
      };
      Hogan4.parse = function(tokens, text, options) {
        options = options || {};
        return buildTree(tokens, "", [], options.sectionTags || []);
      };
      Hogan4.cache = {};
      Hogan4.cacheKey = function(text, options) {
        return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join("||");
      };
      Hogan4.compile = function(text, options) {
        options = options || {};
        var key2 = Hogan4.cacheKey(text, options);
        var template = this.cache[key2];
        if (template) {
          var partials = template.partials;
          for (var name in partials) {
            delete partials[name].instance;
          }
          return template;
        }
        template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
        return this.cache[key2] = template;
      };
    })(typeof exports2 !== "undefined" ? exports2 : Hogan);
  }
});

// node_modules/hogan.js/lib/template.js
var require_template = __commonJS({
  "node_modules/hogan.js/lib/template.js"(exports2) {
    var Hogan4 = {};
    (function(Hogan5) {
      Hogan5.Template = function(codeObj, text, compiler, options) {
        codeObj = codeObj || {};
        this.r = codeObj.code || this.r;
        this.c = compiler;
        this.options = options || {};
        this.text = text || "";
        this.partials = codeObj.partials || {};
        this.subs = codeObj.subs || {};
        this.buf = "";
      };
      Hogan5.Template.prototype = {
        // render: replaced by generated code.
        r: function(context, partials, indent) {
          return "";
        },
        // variable escaping
        v: hoganEscape,
        // triple stache
        t: coerceToString,
        render: function render(context, partials, indent) {
          return this.ri([context], partials || {}, indent);
        },
        // render internal -- a hook for overrides that catches partials too
        ri: function(context, partials, indent) {
          return this.r(context, partials, indent);
        },
        // ensurePartial
        ep: function(symbol, partials) {
          var partial = this.partials[symbol];
          var template = partials[partial.name];
          if (partial.instance && partial.base == template) {
            return partial.instance;
          }
          if (typeof template == "string") {
            if (!this.c) {
              throw new Error("No compiler available.");
            }
            template = this.c.compile(template, this.options);
          }
          if (!template) {
            return null;
          }
          this.partials[symbol].base = template;
          if (partial.subs) {
            if (!partials.stackText)
              partials.stackText = {};
            for (key in partial.subs) {
              if (!partials.stackText[key]) {
                partials.stackText[key] = this.activeSub !== void 0 && partials.stackText[this.activeSub] ? partials.stackText[this.activeSub] : this.text;
              }
            }
            template = createSpecializedPartial(
              template,
              partial.subs,
              partial.partials,
              this.stackSubs,
              this.stackPartials,
              partials.stackText
            );
          }
          this.partials[symbol].instance = template;
          return template;
        },
        // tries to find a partial in the current scope and render it
        rp: function(symbol, context, partials, indent) {
          var partial = this.ep(symbol, partials);
          if (!partial) {
            return "";
          }
          return partial.ri(context, partials, indent);
        },
        // render a section
        rs: function(context, partials, section) {
          var tail = context[context.length - 1];
          if (!isArray2(tail)) {
            section(context, partials, this);
            return;
          }
          for (var i = 0; i < tail.length; i++) {
            context.push(tail[i]);
            section(context, partials, this);
            context.pop();
          }
        },
        // maybe start a section
        s: function(val, ctx, partials, inverted, start, end, tags) {
          var pass;
          if (isArray2(val) && val.length === 0) {
            return false;
          }
          if (typeof val == "function") {
            val = this.ms(val, ctx, partials, inverted, start, end, tags);
          }
          pass = !!val;
          if (!inverted && pass && ctx) {
            ctx.push(typeof val == "object" ? val : ctx[ctx.length - 1]);
          }
          return pass;
        },
        // find values with dotted names
        d: function(key2, ctx, partials, returnFound) {
          var found, names = key2.split("."), val = this.f(names[0], ctx, partials, returnFound), doModelGet = this.options.modelGet, cx = null;
          if (key2 === "." && isArray2(ctx[ctx.length - 2])) {
            val = ctx[ctx.length - 1];
          } else {
            for (var i = 1; i < names.length; i++) {
              found = findInScope(names[i], val, doModelGet);
              if (found !== void 0) {
                cx = val;
                val = found;
              } else {
                val = "";
              }
            }
          }
          if (returnFound && !val) {
            return false;
          }
          if (!returnFound && typeof val == "function") {
            ctx.push(cx);
            val = this.mv(val, ctx, partials);
            ctx.pop();
          }
          return val;
        },
        // find values with normal names
        f: function(key2, ctx, partials, returnFound) {
          var val = false, v = null, found = false, doModelGet = this.options.modelGet;
          for (var i = ctx.length - 1; i >= 0; i--) {
            v = ctx[i];
            val = findInScope(key2, v, doModelGet);
            if (val !== void 0) {
              found = true;
              break;
            }
          }
          if (!found) {
            return returnFound ? false : "";
          }
          if (!returnFound && typeof val == "function") {
            val = this.mv(val, ctx, partials);
          }
          return val;
        },
        // higher order templates
        ls: function(func, cx, partials, text, tags) {
          var oldTags = this.options.delimiters;
          this.options.delimiters = tags;
          this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
          this.options.delimiters = oldTags;
          return false;
        },
        // compile text
        ct: function(text, cx, partials) {
          if (this.options.disableLambda) {
            throw new Error("Lambda features disabled.");
          }
          return this.c.compile(text, this.options).render(cx, partials);
        },
        // template result buffering
        b: function(s) {
          this.buf += s;
        },
        fl: function() {
          var r = this.buf;
          this.buf = "";
          return r;
        },
        // method replace section
        ms: function(func, ctx, partials, inverted, start, end, tags) {
          var textSource, cx = ctx[ctx.length - 1], result = func.call(cx);
          if (typeof result == "function") {
            if (inverted) {
              return true;
            } else {
              textSource = this.activeSub && this.subsText && this.subsText[this.activeSub] ? this.subsText[this.activeSub] : this.text;
              return this.ls(result, cx, partials, textSource.substring(start, end), tags);
            }
          }
          return result;
        },
        // method replace variable
        mv: function(func, ctx, partials) {
          var cx = ctx[ctx.length - 1];
          var result = func.call(cx);
          if (typeof result == "function") {
            return this.ct(coerceToString(result.call(cx)), cx, partials);
          }
          return result;
        },
        sub: function(name, context, partials, indent) {
          var f = this.subs[name];
          if (f) {
            this.activeSub = name;
            f(context, partials, this, indent);
            this.activeSub = false;
          }
        }
      };
      function findInScope(key2, scope, doModelGet) {
        var val;
        if (scope && typeof scope == "object") {
          if (scope[key2] !== void 0) {
            val = scope[key2];
          } else if (doModelGet && scope.get && typeof scope.get == "function") {
            val = scope.get(key2);
          }
        }
        return val;
      }
      function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
        function PartialTemplate() {
        }
        ;
        PartialTemplate.prototype = instance;
        function Substitutions() {
        }
        ;
        Substitutions.prototype = instance.subs;
        var key2;
        var partial = new PartialTemplate();
        partial.subs = new Substitutions();
        partial.subsText = {};
        partial.buf = "";
        stackSubs = stackSubs || {};
        partial.stackSubs = stackSubs;
        partial.subsText = stackText;
        for (key2 in subs) {
          if (!stackSubs[key2])
            stackSubs[key2] = subs[key2];
        }
        for (key2 in stackSubs) {
          partial.subs[key2] = stackSubs[key2];
        }
        stackPartials = stackPartials || {};
        partial.stackPartials = stackPartials;
        for (key2 in partials) {
          if (!stackPartials[key2])
            stackPartials[key2] = partials[key2];
        }
        for (key2 in stackPartials) {
          partial.partials[key2] = stackPartials[key2];
        }
        return partial;
      }
      var rAmp = /&/g, rLt = /</g, rGt = />/g, rApos = /\'/g, rQuot = /\"/g, hChars = /[&<>\"\']/;
      function coerceToString(val) {
        return String(val === null || val === void 0 ? "" : val);
      }
      function hoganEscape(str) {
        str = coerceToString(str);
        return hChars.test(str) ? str.replace(rAmp, "&amp;").replace(rLt, "&lt;").replace(rGt, "&gt;").replace(rApos, "&#39;").replace(rQuot, "&quot;") : str;
      }
      var isArray2 = Array.isArray || function(a) {
        return Object.prototype.toString.call(a) === "[object Array]";
      };
    })(typeof exports2 !== "undefined" ? exports2 : Hogan4);
  }
});

// node_modules/hogan.js/lib/hogan.js
var require_hogan = __commonJS({
  "node_modules/hogan.js/lib/hogan.js"(exports2, module2) {
    var Hogan4 = require_compiler();
    Hogan4.Template = require_template().Template;
    Hogan4.template = Hogan4.Template;
    module2.exports = Hogan4;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LineChangeTrackerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_reflect_metadata = __toESM(require_Reflect());

// src/commands/base.command.ts
var BaseCommand = class {
  /**
   * Creates a new instance of BaseCommand.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance that manages this command
   */
  constructor(plugin) {
    this.plugin = plugin;
  }
};

// src/decorators/inject.decorator.ts
var Inject = (cls) => {
  return (target, propertyKey) => {
    Reflect.defineMetadata("INJECT", true, target, propertyKey);
    Object.defineProperty(target, propertyKey, {
      get() {
        const plugin = this["plugin"];
        if (plugin) {
          return plugin.get(cls);
        }
        throw new Error(`"${target}" does not have a "plugin" property defined.`);
      },
      set(_value) {
        throw new Error("You cannot change the value of a property with a service");
      }
    });
  };
};

// src/helpers/debug.helper.ts
var styles = {
  log: "background: #444; color: #0f0; font-weight: bold; padding: 2px 6px; border-radius: 4px;",
  success: "background: #155724; color: #d4edda; font-weight: bold; padding: 2px 6px; border-radius: 4px;",
  error: "background: #721c24; color: #f8d7da; font-weight: bold; padding: 2px 6px; border-radius: 4px;",
  warn: "background: #856404; color: #fff3cd; font-weight: bold; padding: 2px 6px; border-radius: 4px;",
  info: "background: #046385; color: #d4fff9; font-weight: bold; padding: 2px 6px; border-radius: 4px;"
};
var DebugHelper = class {
  /**
   * Logs a success message with green styling.
   *
   * @param {string} label - The message to display
   * @param {Record<string, unknown>} vars - Optional variables to log along with the message
   * @return {void}
   */
  static success(label, vars) {
    this.log(label, vars, "success");
  }
  /**
   * Logs an error message with red styling.
   *
   * @param {string} label - The message to display
   * @param {Record<string, unknown>} vars - Optional variables to log along with the message
   * @return {void}
   */
  static error(label, vars) {
    this.log(label, vars, "error");
  }
  /**
   * Logs a warning message with yellow styling.
   *
   * @param {string} label - The message to display
   * @param {Record<string, unknown>} vars - Optional variables to log along with the message
   * @return {void}
   */
  static warn(label, vars) {
    this.log(label, vars, "warn");
  }
  /**
   * Logs an informational message with blue styling.
   *
   * @param {string} label - The message to display
   * @param {Record<string, unknown>} vars - Optional variables to log along with the message
   * @return {void}
   */
  static info(label, vars) {
    this.log(label, vars, "info");
  }
  /**
   * Main logging method that all other methods call.
   * Creates a collapsible console group with styled header and displays variables if provided.
   * Includes a stack trace for debugging.
   *
   * @param {string} label - The message to display
   * @param {Record<string, unknown>} vars - Optional variables to log along with the message
   * @param {DebugTheme} theme - The theme to use for styling (defaults to 'log')
   * @return {void}
   */
  static log(label, vars, theme = "log") {
    const timestamp = new Date().toLocaleString();
    const fullLabel = `${label}  [${timestamp}]`;
    console.groupCollapsed(`%c${fullLabel}`, styles[theme]);
    if (vars && Object.keys(vars).length > 0) {
      console.log(vars);
    } else {
      console.log("(no variables)");
    }
    console.trace("Trace");
    console.groupEnd();
  }
};
var debug = Object.assign(
  (...args) => DebugHelper.log(...args),
  {
    log: DebugHelper.log,
    success: DebugHelper.success,
    error: DebugHelper.error,
    warn: DebugHelper.warn,
    info: DebugHelper.info
  }
);

// src/commands/debug.command.ts
var DebugCommand = class extends BaseCommand {
  constructor() {
    super(...arguments);
    /**
     * Unique identifier for this command.
     * Used by Obsidian to register and reference the command.
     */
    this.id = "tracker-debug";
    /**
     * Display name for this command.
     * Shown in the Obsidian command palette.
     */
    this.name = "Log to console debug information";
    /**
     * Callback function executed when the command is triggered.
     * Logs plugin information to the console for debugging.
     */
    this.callback = () => {
      var _a, _b;
      debug.info("Tracker debug information", {
        plugin: this.plugin,
        test: (_b = (_a = this.snapshotsService.getOne()) == null ? void 0 : _a.selfTest()) != null ? _b : null
      });
    };
  }
};
__decorateClass([
  Inject("SnapshotsService")
], DebugCommand.prototype, "snapshotsService", 2);

// src/commands/reset-lines-all.command.ts
var import_obsidian = require("obsidian");
var ResetLinesAllCommand = class extends BaseCommand {
  constructor() {
    super(...arguments);
    /**
     * Unique identifier for this command.
     * Used by Obsidian to register and reference the command.
     */
    this.id = "tracker-reset-lines-all";
    /**
     * Display name for this command.
     * Shown in the Obsidian command palette.
     */
    this.name = "Reset all lines tracker snapshots";
    /**
     * Callback function executed when the command is triggered.
     * Deletes all snapshots and shows a notification.
     */
    this.callback = () => {
      this.snapshotsService.wipe();
      new import_obsidian.Notice("All snapshot data deleted");
    };
  }
};
__decorateClass([
  Inject("SnapshotsService")
], ResetLinesAllCommand.prototype, "snapshotsService", 2);

// src/commands/reset-lines.command.ts
var import_obsidian2 = require("obsidian");
var ResetLinesCommand = class extends BaseCommand {
  constructor() {
    super(...arguments);
    /**
     * Unique identifier for this command.
     * Used by Obsidian to register and reference the command.
     */
    this.id = "tracker-reset-lines";
    /**
     * Display name for this command.
     * Shown in the Obsidian command palette.
     */
    this.name = "Reset lines tracker snapshot of current document";
    /**
     * Callback function executed when the command is triggered in an editor context.
     * Deletes the snapshot for the current document and shows a notification.
     */
    this.editorCallback = () => {
      this.snapshotsService.wipeOne();
      new import_obsidian2.Notice("Current snapshot data deleted");
    };
  }
};
__decorateClass([
  Inject("SnapshotsService")
], ResetLinesCommand.prototype, "snapshotsService", 2);

// src/commands/show-diff.command.ts
var ShowDiffCommand = class extends BaseCommand {
  constructor() {
    super(...arguments);
    /**
     * Unique identifier for this command.
     * Used by Obsidian to register and reference the command.
     */
    this.id = "tracker-show-diff";
    /**
     * Display name for this command.
     * Shown in the Obsidian command palette.
     */
    this.name = "Show all changes of current document";
    /**
     * Callback function executed when the command is triggered in an editor context.
     * Opens a diff modal showing all changes in the current document.
     */
    this.editorCallback = () => {
      this.modalService.diff();
    };
  }
};
__decorateClass([
  Inject("ModalsService")
], ShowDiffCommand.prototype, "modalService", 2);

// src/services/commands.service.ts
var CommandsService = class {
  /**
   * Creates a new instance of CommandsService.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Map of command IDs to command instances.
     * Used to track registered commands and prevent duplicates.
     */
    this.instances = /* @__PURE__ */ new Map();
  }
  /**
   * Initializes the service by registering all plugin commands.
   * Called during plugin initialization.
   */
  init() {
    this.register(ResetLinesCommand);
    this.register(ResetLinesAllCommand);
    this.register(ShowDiffCommand);
    this.register(DebugCommand);
  }
  /**
   * Registers a command with Obsidian.
   * Creates an instance of the command, adds it to the instance map,
   * and registers it with the plugin.
   * Skip registration if a command with the same name already exists.
   *
   * @template T - The command type, extending both BaseCommand and Obsidian Command
   * @param {ClassConstructor<T>} ClsCConstructor - The command class constructor
   */
  register(ClsCConstructor) {
    const command = this.factory(ClsCConstructor);
    if (this.instances.has(command.name)) {
      return;
    }
    this.instances.set(command.id, command);
    this.plugin.addCommand(command);
  }
  /**
   * Creates a new instance of a command.
   * Factory method that instantiates commands with the plugin instance.
   *
   * @template T - The command type, extending both BaseCommand and Obsidian Command
   * @param {ClassConstructor<T>} ClsCConstructor - The command class constructor
   * @return {Command} A new instance of the command
   */
  factory(ClsCConstructor) {
    return new ClsCConstructor(this.plugin);
  }
};

// src/consts.ts
var DEFAULT_SETTINGS = {
  type: "line" /* line */,
  keep: "file" /* file */,
  allowedExtensions: "md, txt, csv, json, yaml",
  ignoreNewFiles: true,
  line: {
    width: 2
  },
  show: {
    changed: true,
    restored: true,
    added: true,
    removed: true
  },
  gutter: {
    changed: "\u2942",
    added: "\u2937",
    restored: "\u293A",
    removed: "\u290E"
  }
};
var STYLE_ID = "line-change-tracker-styles";
var STATUSBAR_ITEM_ID = "default";
var ObsidianVaultEvent = /* @__PURE__ */ ((ObsidianVaultEvent2) => {
  ObsidianVaultEvent2["create"] = "vault.create";
  ObsidianVaultEvent2["modify"] = "vault.modify";
  ObsidianVaultEvent2["delete"] = "vault.delete";
  ObsidianVaultEvent2["rename"] = "vault.rename";
  return ObsidianVaultEvent2;
})(ObsidianVaultEvent || {});
var ObsidianWorkspaceEvent = /* @__PURE__ */ ((ObsidianWorkspaceEvent2) => {
  ObsidianWorkspaceEvent2["activeLeafChange"] = "workspace.active-leaf-change";
  ObsidianWorkspaceEvent2["layoutChange"] = "workspace.layout-change";
  ObsidianWorkspaceEvent2["fileOpen"] = "workspace.file-open";
  ObsidianWorkspaceEvent2["editorMenu"] = "workspace.editor-menu";
  ObsidianWorkspaceEvent2["fileMenu"] = "workspace.file-menu";
  ObsidianWorkspaceEvent2["quit"] = "workspace.quit";
  ObsidianWorkspaceEvent2["resize"] = "workspace.resize";
  ObsidianWorkspaceEvent2["cssChange"] = "workspace.css-change";
  ObsidianWorkspaceEvent2["editorChange"] = "workspace.editor-change";
  ObsidianWorkspaceEvent2["editorPaste"] = "workspace.editor-paste";
  ObsidianWorkspaceEvent2["editorDrop"] = "workspace.editor-drop";
  ObsidianWorkspaceEvent2["windowOpen"] = "workspace.window-open";
  ObsidianWorkspaceEvent2["windowClose"] = "workspace.window-close";
  return ObsidianWorkspaceEvent2;
})(ObsidianWorkspaceEvent || {});
var ObsidianEvent = {
  vault: ObsidianVaultEvent,
  workspace: ObsidianWorkspaceEvent
};

// src/events/base.event.ts
var BaseEvent = class {
  /**
   * Creates a new instance of BaseEvent.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance that manages this event
   */
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Gets the appropriate trigger element (workspace or vault) based on the event type.
   *
   * @param {string} type - The type of event trigger ("workspace" or "vault")
   * @return {EventTriggerElement} The corresponding trigger element
   * @throws Error if the trigger type is unknown
   */
  getTrigger(type) {
    const trigger = {
      workspace: this.plugin.app.workspace,
      vault: this.plugin.app.vault
    }[type];
    if (!trigger) {
      throw new Error(`Unknown trigger type: ${type}`);
    }
    return trigger;
  }
  /**
   * Parses the event name into its component parts.
   * Splits the name into type and name components
   * (e.g., "workspace.file-open" -> {type: "workspace", name: "file-open"}).
   *
   * @return {Object} An object containing the type and name components
   * @throws Error if the event name is not in the correct format
   */
  getTypeName() {
    const arr = this.name.split(".");
    if (arr.length !== 2) {
      throw new Error(`Invalid event name: ${this.name}`);
    }
    return { type: arr[0], name: arr[1] };
  }
  /**
   * Registers the event handler with Obsidian.
   * Uses the event name to determine the appropriate trigger and register the handler method.
   *
   * @return {EventRef} An EventRef that can be used to unregister the event
   */
  register() {
    const { name, type } = this.getTypeName();
    return this.getTrigger(type).on(
      name,
      this.handler,
      this
    );
  }
  /**
   * Unregisters the event handler from Obsidian.
   * Removes the event listener to prevent memory leaks when the plugin is disabled.
   *
   * @return {void}
   */
  unregister() {
    const { name, type } = this.getTypeName();
    return this.getTrigger(type).off(
      name,
      this.handler
    );
  }
};

// src/events/vault/create.event.ts
var import_obsidian3 = require("obsidian");
var VaultCreateEvent = class extends BaseEvent {
  constructor() {
    super(...arguments);
    /**
     * The name of the Obsidian event to handle.
     * Set to the vault.create event.
     */
    this.name = ObsidianEvent.vault.create;
  }
  /**
   * Handles the vault create event by managing the ignore list for new files.
   * If the "ignore new files" setting is enabled and the file has an allowed extension,
   * adds the file to the ignore list to prevent change tracking.
   *
   * @param {TAbstractFile} file - The file that was created in the vault
   */
  handler(file) {
    if (!(file instanceof import_obsidian3.TFile)) {
      return;
    }
    if (this.settingsService.value("ignoreNewFiles") && this.snapshotsService.isInAllowedExtensions(file)) {
      this.snapshotsService.addToIgnoreList(file);
    }
  }
};
__decorateClass([
  Inject("SettingsService")
], VaultCreateEvent.prototype, "settingsService", 2);
__decorateClass([
  Inject("SnapshotsService")
], VaultCreateEvent.prototype, "snapshotsService", 2);

// src/events/vault/modify.event.ts
var VaultModifyEvent = class extends BaseEvent {
  constructor() {
    super(...arguments);
    /**
     * The name of the Obsidian event to handle.
     * Set to the vault.modify event.
     */
    this.name = ObsidianEvent.vault.modify;
  }
  /**
   * Handles the vault modify event.
   * Processes the front matter of the modified file.
   * Currently, doesn't perform any actions with the processed front matter.
   *
   * @param {...any} _args - Arguments passed by the event, containing the modified file
   */
  handler(..._args) {
  }
};

// src/events/workspace/active-leaf-change.event.ts
var WorkspaceActiveLeafChangeEvent = class extends BaseEvent {
  constructor() {
    super(...arguments);
    /**
     * The name of the Obsidian event to handle.
     * Set to the workspace.activeLeafChange event.
     */
    this.name = ObsidianEvent.workspace.activeLeafChange;
  }
  /**
   * Handles the active leaf change event.
   * Forces an update of the snapshots to ensure they reflect the current state.
   *
   * @param {...any} args - Arguments passed by the event (not used in this handler)
   */
  handler(...args) {
    const [] = args;
    this.snapshotsService.forceUpdate();
  }
};
__decorateClass([
  Inject("SnapshotsService")
], WorkspaceActiveLeafChangeEvent.prototype, "snapshotsService", 2);

// src/events/workspace/editor-menu.event.ts
var WorkspaceEditorMenuEvent = class extends BaseEvent {
  constructor() {
    super(...arguments);
    /**
     * The name of the Obsidian event to handle.
     * Set to the workspace.editorMenu event.
     */
    this.name = ObsidianEvent.workspace.editorMenu;
  }
  /**
   * Handles the editor menu event by adding a custom menu item.
   * Adds a "Local history" item that opens the diff modal when clicked.
   *
   * @param {Menu} menu - The menu to add items to
   * @param {Editor} _editor - The editor instance (not used in this handler)
   * @param {MarkdownView} _view - The Markdown view (not used in this handler)
   */
  handler(menu, _editor, _view) {
    menu.addItem((item) => {
      item.setTitle("Local history").setIcon("file-diff").onClick(() => {
        this.modalService.diff();
      });
    });
  }
};
__decorateClass([
  Inject("ModalsService")
], WorkspaceEditorMenuEvent.prototype, "modalService", 2);

// src/events/workspace/file-open.event.ts
var WorkspaceFileOpenEvent = class extends BaseEvent {
  constructor() {
    super(...arguments);
    /**
     * The name of the Obsidian event to handle.
     * Set to the workspace.fileOpen event.
     */
    this.name = ObsidianEvent.workspace.fileOpen;
  }
  /**
   * Handles the file open event by capturing a snapshot of the file.
   * Skips processing if no file is provided (null check).
   *
   * @param {TFile | null} file - The file that was opened or null if no file
   */
  handler(file) {
    if (!file) {
      return;
    }
    void this.snapshotsService.capture(file);
  }
};
__decorateClass([
  Inject("SnapshotsService")
], WorkspaceFileOpenEvent.prototype, "snapshotsService", 2);

// src/events/workspace/files-menu.event.ts
var import_obsidian4 = require("obsidian");
var import_obsidian5 = require("obsidian");
var WorkspaceFilesMenuEvent = class extends BaseEvent {
  constructor() {
    super(...arguments);
    /**
     * The name of the Obsidian event to handle.
     * Set to the workspace.fileMenu event.
     */
    this.name = ObsidianEvent.workspace.fileMenu;
  }
  /**
   * Handles the file menu event by adding a custom menu item.
   * Adds a "Local history" item that opens the diff modal when clicked.
   * Shows a notice if there's no history available for the file.
   *
   * @param {Menu} menu - The menu to add items to
   * @param {TAbstractFile} file - The file the menu was opened for
   * @param {string} _source - The source of the menu event (not used in this handler)
   * @param {WorkspaceLeaf} _leaf - The workspace leaf (not used in this handler)
   */
  handler(menu, file, _source, _leaf) {
    if (!(file instanceof import_obsidian4.TFile)) {
      return;
    }
    menu.addItem((item) => {
      item.setTitle("Local history").setIcon("file-diff").onClick(() => {
        if (!this.modalService.diff(file)) {
          new import_obsidian5.Notice("There is no saved history for this file.");
        }
      });
    });
  }
};
__decorateClass([
  Inject("ModalsService")
], WorkspaceFilesMenuEvent.prototype, "modalService", 2);

// src/events/workspace/layout-change.event.ts
var WorkspaceLayoutChangeEvent = class extends BaseEvent {
  constructor() {
    super(...arguments);
    /**
     * The name of the Obsidian event to handle.
     * Set to the workspace.layoutChange event.
     */
    this.name = ObsidianEvent.workspace.layoutChange;
  }
  /**
   * Handles the layout change event by managing snapshots.
   * Performs two main tasks:
   * 1. Removes snapshots for files that have been closed (if configured to not keep history)
   * 2. Creates snapshots for newly opened files that don't have snapshots yet
   */
  handler() {
    const openedFiles = this.plugin.getWorkspaceFiles();
    this.snapshotsService.getList().forEach((snapshot) => {
      if (!snapshot.file || !this.isOnFileClose()) {
        return;
      }
      if (!openedFiles.has(snapshot.file)) {
        this.snapshotsService.wipeOne(snapshot.file);
      }
    });
    this.snapshotsService.getIgnoreList().forEach((file) => {
      if (!openedFiles.has(file)) {
        this.snapshotsService.removeFromIgnoreList(file);
      }
    });
    openedFiles.forEach((file) => {
      if (!this.snapshotsService.getOne(file)) {
        void this.snapshotsService.capture(file);
      }
    });
  }
  /**
   * Checks if the plugin is configured to remove snapshots when files are closed.
   *
   * @return {boolean} True if the keep history setting is set to 'file', false otherwise
   */
  isOnFileClose() {
    return this.settingsService.value("keep") === "file" /* file */;
  }
};
__decorateClass([
  Inject("SnapshotsService")
], WorkspaceLayoutChangeEvent.prototype, "snapshotsService", 2);
__decorateClass([
  Inject("SettingsService")
], WorkspaceLayoutChangeEvent.prototype, "settingsService", 2);

// src/services/events.service.ts
var EventsService = class {
  /**
   * Creates a new instance of EventsService.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Set of event instances.
     * Used to track registered events and prevent duplicates.
     */
    this.instances = /* @__PURE__ */ new Set();
  }
  /**
   * Initializes the service by registering all plugin events.
   * Called during plugin initialization.
   */
  init() {
    this.register(WorkspaceActiveLeafChangeEvent);
    this.register(WorkspaceFileOpenEvent);
    this.register(WorkspaceLayoutChangeEvent);
    this.register(WorkspaceEditorMenuEvent);
    this.register(WorkspaceFilesMenuEvent);
    this.register(VaultModifyEvent);
    this.register(VaultCreateEvent);
  }
  /**
   * Registers an event with Obsidian.
   * Creates an instance of the event, adds it to the instance set,
   * and registers it with the plugin.
   * Skip registration if the event already exists in the set.
   *
   * @template T - The event type, extending BaseEvent
   * @param {ClassConstructor<T>} ClsCConstructor - The event class constructor
   */
  register(ClsCConstructor) {
    const event = this.factory(ClsCConstructor);
    if (this.instances.has(event)) {
      return;
    }
    this.instances.add(event);
    this.plugin.registerEvent(event.register());
  }
  /**
   * Creates a new instance of an event.
   * Factory method that instantiates events with the plugin instance.
   *
   * @template T - The event type, extending BaseEvent
   * @param {ClassConstructor<T>} ClsCConstructor - The event class constructor
   * @return {BaseEvent} A new instance of the event
   */
  factory(ClsCConstructor) {
    return new ClsCConstructor(this.plugin);
  }
};

// src/extensions/base.extension.ts
var BaseExtension = class {
  /**
   * Creates a new instance of BaseExtension.
   *
   * @param {EditorView | null} view - The CodeMirror editor view this extension is attached to
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance that manages this extension
   */
  constructor(view, plugin) {
    this.view = view;
    this.plugin = plugin;
  }
};

// src/extensions/change-detector.extension.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var ChangeDetectorExtension = class extends BaseExtension {
  constructor() {
    super(...arguments);
    /**
     * Set of decorations to be applied to the editor.
     * Initialized with an empty decoration set.
     */
    this.decorations = import_view.Decoration.none;
  }
  /**
   * Handles updates to the editor view.
   * Processes document changes to track line modifications.
   *
   * @param {ViewUpdate} update - The view update event from CodeMirror
   */
  update(update) {
    if (!update.docChanged) {
      return;
    }
    this.processIncrementalChanges(update);
  }
  /**
   * Processes incremental changes in the document.
   * Checks if the content has changed and computes the changes if needed.
   *
   * @param {ViewUpdate} update - The view update event from CodeMirror
   */
  processIncrementalChanges(update) {
    var _a;
    const currentContent = (_a = this.view) == null ? void 0 : _a.state.doc.toString();
    const snapshot = this.snapshotsService.getOne();
    if (!snapshot || !currentContent) {
      return;
    }
    if (!snapshot.isNeedUpdate(currentContent)) {
      return;
    }
    this.computeIncrementalChanges(update.changes);
    this.snapshotsService.forceUpdate();
  }
  /**
   * Computes incremental changes in the document based on the ChangeSet.
   * Tracks line additions, modifications, and removals to maintain change history.
   * Updates the file snapshot with the new state after processing all changes.
   *
   * @param {ChangeSet} changes - The ChangeSet from CodeMirror containing all document changes
   * @return {void}
   */
  computeIncrementalChanges(changes) {
    var _a;
    const state = (_a = this.view) == null ? void 0 : _a.state;
    const currentLines = state.doc.toString().split(state.lineBreak) || [];
    const snapshot = this.snapshotsService.getOne();
    const prev = import_state.Text.of(snapshot.getLastStateLines() || currentLines);
    changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
      const fromNewLine = state.doc.lineAt(fromB).number - 1;
      const toNewLine = state.doc.lineAt(toB).number - 1;
      const fromOldLine = prev.lineAt(fromA).number - 1;
      const toOldLine = prev.lineAt(toA).number - 1;
      const start = Math.min(fromNewLine, toNewLine);
      const line = inserted.iterLines();
      let offset = 0;
      const linesDiffCount = fromOldLine - toOldLine + (toNewLine - fromNewLine);
      if (linesDiffCount < 0) {
        for (let i = 0; i <= Math.abs(linesDiffCount) - 1; i++) {
          const index = toOldLine - i;
          snapshot.removeTrackerOrLine(index);
        }
      }
      if (linesDiffCount > 0) {
        for (let i = 1; i <= Math.abs(linesDiffCount); i++) {
          const index = fromNewLine + i;
          snapshot.restoreOrAddTracker(index);
        }
      }
      do {
        const lineNumber = offset + start;
        const tracker = snapshot.findCurrentLine(lineNumber);
        if (offset >= inserted.lines) {
          continue;
        }
        tracker == null ? void 0 : tracker.change(currentLines[lineNumber]);
        offset++;
      } while (!line.next().done);
    }, true);
    snapshot.updateState(currentLines);
    snapshot.updateChanges();
  }
};
__decorateClass([
  Inject("SnapshotsService")
], ChangeDetectorExtension.prototype, "snapshotsService", 2);

// src/extensions/editor-common.extension.ts
var import_state2 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var EditorCommonExtension = class extends BaseExtension {
  constructor() {
    super(...arguments);
    /**
     * Set of decorations to be applied to the editor.
     * Initialized with an empty decoration set.
     */
    this.decorations = import_view2.Decoration.none;
  }
  // todo remember hash to avoid restarting re-render
  /**
   * Handles updates to the editor view.
   * Updates decorations when the document changes.
   *
   * @param {ViewUpdate} update - The view update event from CodeMirror
   * @return {void}
   */
  update(update) {
    if (!update.docChanged) {
    }
    this.updateDecorations();
  }
  /**
   * Updates the decorations based on the current snapshot.
   * Clears decorations if the indicator type is not 'line' or if no snapshot exists.
   */
  updateDecorations() {
    const snapshot = this.snapshotsService.getOne();
    if (!this.isTypeLine() || !snapshot) {
      this.decorations = import_view2.Decoration.none;
      return;
    }
    this.buildDecorations();
  }
  /**
   * Builds the decoration set based on the changes in the snapshot.
   * Creates line decorations for each line that has changes of enabled types.
   *
   * @return {DecorationSet} The built decoration set
   */
  buildDecorations() {
    var _a;
    const builder = new import_state2.RangeSetBuilder();
    const enable = this.getEnableTypes();
    const snapshot = this.snapshotsService.getOne();
    const changes = snapshot == null ? void 0 : snapshot.getChanges(enable);
    for (let i = 0; i <= this.view.state.doc.lines - 1; i++) {
      const line = this.view.state.doc.line(i + 1);
      const change = (_a = changes == null ? void 0 : changes.get(i)) != null ? _a : null;
      const classNames = ["lct", `lct-${"line" /* line */}`];
      if (!change) {
        continue;
      }
      change.getTypes().forEach((type) => {
        classNames.push(`lct-${type}`);
      });
      const decoration = import_view2.Decoration.line({
        attributes: {
          class: classNames.join(" ")
        }
      });
      builder.add(line.from, line.from, decoration);
    }
    this.decorations = builder.finish();
    return this.decorations;
  }
  /**
   * Checks if the indicator type is set to 'line'.
   *
   * @return {boolean} True if the indicator type is 'line', false otherwise
   */
  isTypeLine() {
    return this.settingsService.value("type") === "line" /* line */;
  }
  /**
   * Gets the enabled change types from settings.
   * Includes only the types that are enabled in the settings.
   *
   * @return {ChangeType[]} Array of enabled change types
   */
  getEnableTypes() {
    return [
      ...this.settingsService.value("show.changed") ? ["changed" /* changed */] : [],
      ...this.settingsService.value("show.restored") ? ["restored" /* restored */] : [],
      ...this.settingsService.value("show.added") ? ["added" /* added */] : [],
      ...this.settingsService.value("show.removed") ? ["removed" /* removed */] : []
    ];
  }
};
__decorateClass([
  Inject("SettingsService")
], EditorCommonExtension.prototype, "settingsService", 2);
__decorateClass([
  Inject("SnapshotsService")
], EditorCommonExtension.prototype, "snapshotsService", 2);

// src/markers/char.marker.ts
var import_view3 = require("@codemirror/view");
var _DotMarker = class extends import_view3.GutterMarker {
  /**
   * Creates a new instance of DotMarker.
   *
   * @param {ChangeType} changes - The type of change this marker represents
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(changes, plugin) {
    super();
    this.changes = changes;
    this.plugin = plugin;
    /**
     * Map of change types to their corresponding gutter characters.
     * Characters are retrieved from plugin settings.
     */
    this.char = {
      ["changed" /* changed */]: this.settingsService.value("gutter.changed"),
      ["added" /* added */]: this.settingsService.value("gutter.added"),
      ["restored" /* restored */]: this.settingsService.value("gutter.restored")
    };
    // protected char: string = this.settingsService.value('gutterChar');
    /**
     * CSS class applied to the gutter marker element.
     * Combines the dot indicator type with the specific change type.
     */
    this.elementClass = `lct-${"dot" /* dot */} lct-${this.changes}`;
  }
  /**
   * Creates a DOM node for the gutter marker.
   * Returns a text node containing the character for this marker's change type.
   *
   * @return {Node} A DOM text node with the appropriate character
   * @override
   */
  toDOM() {
    return document.createTextNode(this.char[this.changes]);
  }
  /**
   * Checks if this marker is equal to another marker.
   * Markers are considered equal if they have the same change type and character.
   *
   * @param {DotMarker} other - The marker to compare with
   * @return {boolean} True if the markers are equal, false otherwise
   * @override
   */
  eq(other) {
    if (!(other instanceof _DotMarker)) {
      return false;
    }
    return this.getChangeType() === other.getChangeType() && this.getChar() === other.getChar();
  }
  /**
   * Gets the change type of this marker.
   *
   * @return {ChangeType} The change type (added, modified, restored)
   */
  getChangeType() {
    return this.changes;
  }
  /**
   * Gets the character used for this marker.
   *
   * @return {string} The character from settings for this marker's change type
   */
  getChar() {
    return this.char[this.changes];
  }
};
var DotMarker = _DotMarker;
__decorateClass([
  Inject("SettingsService")
], DotMarker.prototype, "settingsService", 2);

// src/extensions/gutter-common.extension.ts
var import_state3 = require("@codemirror/state");
var GutterCommonExtension = class extends BaseExtension {
  constructor() {
    super(...arguments);
    /**
     * CSS class for the gutter element.
     * Combines the base plugin class with the dot indicator type.
     */
    this.class = `lct lct-gutter lct-${"dot" /* dot */}`;
    /**
     * Whether to render empty elements in the gutter.
     * Set too false to only show markers for lines with changes.
     */
    this.renderEmptyElements = false;
    /**
     * Creates markers for the gutter-based online changes.
     * Returns a RangeSet of DotMarker instances for lines with changes.
     *
     * @param {EditorView} view - The editor view to create markers for
     * @return {RangeSet<DotMarker>} A RangeSet of DotMarker instances
     */
    this.markers = (view) => {
      var _a;
      const enable = this.getEnableTypes();
      const snapshot = this.snapshotsService.getOne();
      const changes = (_a = snapshot == null ? void 0 : snapshot.getChanges(enable)) != null ? _a : null;
      const builder = new import_state3.RangeSetBuilder();
      if (!this.isTypeDot() || !snapshot || !(changes == null ? void 0 : changes.size)) {
        return builder.finish();
      }
      for (let i = 0; i <= view.state.doc.lines - 1; i++) {
        const line = view.state.doc.line(i + 1);
        const change = changes.get(i);
        if (change) {
          builder.add(line.from, line.from, new DotMarker(change.getModify(), this.plugin));
        }
      }
      return builder.finish();
    };
  }
  /**
   * Checks if the indicator type is set to 'dot'.
   *
   * @return {boolean} True if the indicator type is 'dot', false otherwise
   */
  isTypeDot() {
    return this.settingsService.value("type") === "dot" /* dot */;
  }
  /**
   * Gets the enabled change types from settings.
   * Includes only the types that are enabled in the settings.
   * Note: Unlike editor extension, this doesn't include 'removed' type
   * as removed lines are handled separately.
   *
   * @return {ChangeType[]} Array of enabled change types
   */
  getEnableTypes() {
    return [
      ...this.settingsService.value("show.changed") ? ["changed" /* changed */] : [],
      ...this.settingsService.value("show.restored") ? ["restored" /* restored */] : [],
      ...this.settingsService.value("show.added") ? ["added" /* added */] : []
    ];
  }
};
__decorateClass([
  Inject("SettingsService")
], GutterCommonExtension.prototype, "settingsService", 2);
__decorateClass([
  Inject("SnapshotsService")
], GutterCommonExtension.prototype, "snapshotsService", 2);

// src/markers/removed.marker.ts
var import_view4 = require("@codemirror/view");
var RemovedMarker = class extends import_view4.GutterMarker {
  /**
   * Creates a new instance of RemovedMarker.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(plugin) {
    super();
    this.plugin = plugin;
    /**
     * CSS class applied to the gutter marker element.
     * Combines the dot indicator type with the removed change type.
     */
    this.elementClass = `lct-${"dot" /* dot */} lct-${"removed" /* removed */}`;
  }
  /**
   * Creates a DOM node for the gutter marker.
   * Returns a text node containing the character for removed lines from settings.
   *
   * @return {Node} A DOM text node with the appropriate character
   * @override
   */
  toDOM() {
    return document.createTextNode(this.settingsService.value("gutter.removed"));
  }
};
__decorateClass([
  Inject("SettingsService")
], RemovedMarker.prototype, "settingsService", 2);

// src/extensions/gutter-removed.extension.ts
var import_state4 = require("@codemirror/state");
var GutterRemovedExtension = class extends BaseExtension {
  constructor() {
    super(...arguments);
    /**
     * CSS class for the gutter element.
     * Combines the base plugin class with the dot indicator type and remove a change type.
     */
    this.class = `lct lct-gutter lct-${"dot" /* dot */} lct-${"removed" /* removed */}`;
    /**
     * Whether to render empty elements in the gutter.
     * Set too false to only show markers for lines with changes.
     */
    this.renderEmptyElements = false;
    /**
     * Creates markers for the gutter to indicate removed lines.
     * Returns a RangeSet of RemovedMarker instances for positions where lines were removed.
     *
     * @param {EditorView} view - The editor view to create markers for
     * @return {RangeSet<RemovedMarker>} A RangeSet of RemovedMarker instances
     */
    this.markers = (view) => {
      var _a;
      const snapshot = this.snapshotsService.getOne();
      const removed = (_a = snapshot == null ? void 0 : snapshot.getChanges("removed" /* removed */)) != null ? _a : null;
      const builder = new import_state4.RangeSetBuilder();
      if (!this.isTypeDot() || !this.isEnable() || !snapshot || !removed || removed.size === 0) {
        return builder.finish();
      }
      for (let i = 1; i <= view.state.doc.lines; i++) {
        const line = view.state.doc.line(i);
        if (removed.has(line.number - 1) && !removed.has(line.number - 2)) {
          builder.add(line.from, line.from, new RemovedMarker(this.plugin));
        }
      }
      return builder.finish();
    };
  }
  /**
   * Checks if the indicator type is set to 'dot'.
   *
   * @return {boolean} True if the indicator type is 'dot', false otherwise
   */
  isTypeDot() {
    return this.settingsService.value("type") === "dot" /* dot */;
  }
  /**
   * Checks if showing removed lines is enabled in settings.
   *
   * @return {boolean} True if showing removed lines is enabled, false otherwise
   */
  isEnable() {
    return this.settingsService.value("show.removed");
  }
};
__decorateClass([
  Inject("SettingsService")
], GutterRemovedExtension.prototype, "settingsService", 2);
__decorateClass([
  Inject("SnapshotsService")
], GutterRemovedExtension.prototype, "snapshotsService", 2);

// src/services/extensions.service.ts
var import_view5 = require("@codemirror/view");
var ExtensionsService = class {
  /**
   * Creates a new instance of ExtensionsService.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Map of extension names to their instances.
     * Used to track registered extensions and prevent duplicates.
     */
    this.instances = /* @__PURE__ */ new Map();
  }
  /**
   * Initializes the service by registering all plugin extensions.
   * Called during plugin initialization.
   */
  init() {
    this.register(ChangeDetectorExtension, "editor");
    this.register(EditorCommonExtension, "editor");
    this.register(GutterCommonExtension, "gutter");
    this.register(GutterRemovedExtension, "gutter");
  }
  /**
   * Registers an extension with Obsidian.
   * Creates an instance of the extension, adds it to the instance map,
   * and registers it with the plugin.
   * Skip registration if an extension with the same name already exists.
   *
   * @template T - The extension type, either EditorExtension or GutterConfig
   * @param {ClassConstructor<T>} clsConstructor - The extension class constructor
   * @param {string} type - The type of extension ('editor' or 'gutter')
   */
  register(clsConstructor, type) {
    const extension = this.factory(clsConstructor, type);
    if (!extension || this.instances.has(clsConstructor.name)) {
      return;
    }
    this.instances.set(clsConstructor.name, extension);
    this.plugin.registerEditorExtension(extension);
  }
  /**
   * Creates a new extension based on the specified type.
   * Implementation of the factory method that handles both extension types.
   *
   * @template T - The extension type, either EditorExtension or GutterConfig
   * @param {ClassConstructor<T>} clsConstructor - The extension class constructor
   * @param {string} type - The type of extension ('editor' or 'gutter')
   * @return {Extension|ViewPlugin} Either a CodeMirror Extension or ViewPlugin
   * @throws Error if the extension type is unknown
   */
  factory(clsConstructor, type) {
    var _a;
    const plugin = this.plugin;
    switch (type) {
      case "editor":
        return import_view5.ViewPlugin.define(
          // eslint-disable-next-line new-cap
          (view, arg) => new clsConstructor(view, plugin, arg),
          {
            decorations: (view) => {
              var _a2;
              return (_a2 = view.decorations) != null ? _a2 : import_view5.Decoration.none;
            }
          }
        );
      case "gutter":
        return (0, import_view5.gutter)(new clsConstructor(null, plugin));
      default:
        throw Error(`Unknown extension type "${type}" for "${(_a = clsConstructor == null ? void 0 : clsConstructor.name) != null ? _a : "unknown"}"`);
    }
  }
};

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key2) {
  return object == null ? void 0 : object[key2];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key2) {
  var value = getValue_default(object, key2);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key2, value) {
  if (key2 == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key2] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function assignValue(object, key2, value) {
  var objValue = object[key2];
  if (!(hasOwnProperty3.call(object, key2) && eq_default(objValue, value)) || value === void 0 && !(key2 in object)) {
    baseAssignValue_default(object, key2, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty5.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
    isIndex_default(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty6.call(object, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key2];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty7.call(data, key2) ? data[key2] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate_default ? data[key2] !== void 0 : hasOwnProperty8.call(data, key2);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key2) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data = this.__data__, index = assocIndexOf_default(data, key2);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key2) {
  var data = this.__data__, index = assocIndexOf_default(data, key2);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key2) {
  return assocIndexOf_default(this.__data__, key2) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key2, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key2);
  if (index < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map, key2) {
  var data = map.__data__;
  return isKeyable_default(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key2) {
  var result = getMapData_default(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key2) {
  return getMapData_default(this, key2).get(key2);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key2) {
  return getMapData_default(this, key2).has(key2);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key2, value) {
  var data = getMapData_default(this, key2), size = data.size;
  data.set(key2, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key2, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto11 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty9.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_default(value) ? value : [value];
}
var castArray_default = castArray;

// node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key2) {
    result[++index] = [key2, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object, props) {
  return arrayMap_default(props, function(key2) {
    return [key2, object[key2]];
  });
}
var baseToPairs_default = baseToPairs;

// node_modules/lodash-es/_setToPairs.js
function setToPairs(set2) {
  var index = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index] = [value, value];
  });
  return result;
}
var setToPairs_default = setToPairs;

// node_modules/lodash-es/_createToPairs.js
var mapTag3 = "[object Map]";
var setTag3 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag_default(object);
    if (tag == mapTag3) {
      return mapToArray_default(object);
    }
    if (tag == setTag3) {
      return setToPairs_default(object);
    }
    return baseToPairs_default(object, keysFunc(object));
  };
}
var createToPairs_default = createToPairs;

// node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default);
var toPairs_default = toPairs;

// node_modules/lodash-es/isString.js
var stringTag2 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag2;
}
var isString_default = isString;

// node_modules/lodash-es/isNumber.js
var numberTag2 = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike_default(value) && baseGetTag_default(value) == numberTag2;
}
var isNumber_default = isNumber;

// node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined;

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key2 = toKey_default(path[index]), newValue = value;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key2];
      newValue = customizer ? customizer(objValue, key2, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key2, newValue);
    nested = nested[key2];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/set.js
function set(object, path, value) {
  return object == null ? object : baseSet_default(object, path, value);
}
var set_default = set;

// src/helpers/dom.helper.ts
var DomHelper = class {
  /**
   * Creates a DOM element based on the provided configuration.
   * @param {DomElementConfig} config - Configuration object for the element
   * @return {HTMLElement} The created HTML element with proper typing
   */
  static create(config) {
    const element = document.createElement(config.tag);
    this.update(element, config);
    if (config.container) {
      config.container.appendChild(element);
    }
    return element;
  }
  /**
   * Creates a DocumentFragment with child elements based on the provided configuration.
   * @param {DomElementConfig[]} children - Array of child element configurations
   * @return {DocumentFragment} The created DocumentFragment with child elements
   */
  static createFragment(children) {
    const fragment = document.createDocumentFragment();
    children.forEach((childConfig) => {
      fragment.appendChild(DomHelper.create(childConfig));
    });
    return fragment;
  }
  /**
   * Updates an existing DOM element based on the provided configuration.
   * @param {HTMLElement} element - The element to update
   * @param {DomUpdateConfig} config - Configuration object for updating the element
   * @return {void}
   */
  static update(element, config) {
    var _a, _b;
    if (!element) {
      return;
    }
    if (config.classes) {
      if (isArray_default(config.classes) || isString_default(config.classes)) {
        element.classList.add(
          ...castArray_default(config.classes)
        );
      }
      if (isPlainObject_default(config.classes)) {
        element.classList.add(
          ...castArray_default((_a = config.classes.add) != null ? _a : [])
        );
        element.classList.remove(
          ...castArray_default((_b = config.classes.remove) != null ? _b : [])
        );
      }
    }
    if (!isUndefined_default(config.text)) {
      element.textContent = config.text;
    }
    if (!isUndefined_default(config.html)) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(config.html, "text/html");
      element.empty();
      Array.from(doc.body.childNodes).forEach((child) => {
        element.appendChild(child);
      });
    }
    if (config.attributes) {
      toPairs_default(config.attributes).forEach(([key2, value]) => {
        try {
          element.setAttribute(key2, value);
        } catch (_error) {
        }
      });
    }
    if (config.styles) {
      toPairs_default(config.styles).forEach(([key2, value]) => {
        if (isUndefined_default(value)) {
          return;
        }
        try {
          element.style.setProperty(key2, String(value));
        } catch (_error) {
        }
      });
    }
    if (config.events) {
      toPairs_default(config.events).forEach(([eventType, handler]) => {
        element.addEventListener(eventType, handler);
      });
    }
    if (config.children) {
      config.children.forEach((childConfig) => {
        element.appendChild(DomHelper.create(childConfig));
      });
    }
  }
};

// src/modals/confirm.modal.ts
var import_obsidian6 = require("obsidian");
var ConfirmModal = class extends import_obsidian6.Modal {
  /**
   * Creates a new instance of ConfirmModal.
   *
   * @param {App} app - The Obsidian app instance
   * @param {ConfirmModalConfig} config - Configuration object for the modal
   */
  constructor(app, config) {
    var _a, _b, _c, _d;
    super(app);
    /**
     * The result of the user's choice.
     * True if confirmed, false if canceled.
     */
    this.result = false;
    this.title = (_a = config.title) != null ? _a : "Confirmation";
    this.message = (_b = config.message) != null ? _b : "Are you sure you want to proceed?";
    this.confirmText = (_c = config.confirmText) != null ? _c : "Confirm";
    this.cancelText = (_d = config.cancelText) != null ? _d : "Cancel";
  }
  /**
   * Called when the modal is opened.
   * Creates the modal content with title, message, and action buttons.
   * Sets up event handlers for the buttons and focused the confirmation button.
   *
   * @override
   */
  onOpen() {
    DomHelper.update(this.contentEl, {
      text: null,
      children: [
        {
          tag: "div",
          children: [
            {
              tag: "h2",
              text: this.title
            },
            {
              tag: "p",
              text: this.message
            },
            {
              tag: "div",
              classes: "modal-button-container",
              styles: {
                display: "flex",
                justifyContent: "flex-end",
                gap: "10px",
                marginTop: "20px"
              },
              children: [
                {
                  tag: "button",
                  text: this.cancelText,
                  events: {
                    click: () => {
                      this.result = false;
                      this.close();
                    }
                  }
                },
                {
                  tag: "button",
                  text: this.confirmText,
                  classes: "mod-warning",
                  events: {
                    click: () => {
                      this.result = true;
                      this.close();
                    }
                  }
                }
              ]
            }
          ]
        }
      ]
    });
    const confirmButton = this.contentEl.querySelector("button.mod-warning");
    confirmButton == null ? void 0 : confirmButton.focus();
  }
  /**
   * Called when the modal is closed.
   * Resolves the promise with the user's choice (result).
   * This ensures the confirm() method returns the appropriate boolean value.
   *
   * @override
   */
  onClose() {
    if (this.resolvePromise) {
      this.resolvePromise(this.result);
    }
  }
  /**
   * Shows the confirmation modal and returns a promise that resolves with the user's choice.
   * Opens the modal and waits for the user to either confirm or cancel.
   *
   * @return {Promise<boolean>} Promise that resolves to true if confirmed, false if canceled
   */
  async confirm() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      this.open();
    });
  }
};

// node_modules/diff/libesm/diff/base.js
var Diff = class {
  diff(oldStr, newStr, options = {}) {
    let callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if ("callback" in options) {
      callback = options.callback;
    }
    const oldString = this.castInput(oldStr, options);
    const newString = this.castInput(newStr, options);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
    const newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a;
    const done = (value) => {
      value = this.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return void 0;
      } else {
        return value;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(void 0);
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path, added, removed, oldPosInc, options) {
    const last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array) {
    const ret = [];
    for (let i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value, options) {
    return value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value, options) {
    return Array.from(value);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value = newTokens.slice(newPos, newPos + component.count);
          value = value.map(function(value2, i) {
            const oldValue = oldTokens[oldPos + i];
            return oldValue.length > value2.length ? oldValue : value2;
          });
          component.value = this.join(value);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
};

// node_modules/diff/libesm/diff/line.js
var LineDiff = class extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize;
  }
  equals(left, right, options) {
    if (options.ignoreWhitespace) {
      if (!options.newlineIsToken || !left.includes("\n")) {
        left = left.trim();
      }
      if (!options.newlineIsToken || !right.includes("\n")) {
        right = right.trim();
      }
    } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
      if (left.endsWith("\n")) {
        left = left.slice(0, -1);
      }
      if (right.endsWith("\n")) {
        right = right.slice(0, -1);
      }
    }
    return super.equals(left, right, options);
  }
};
var lineDiff = new LineDiff();
function diffLines(oldStr, newStr, options) {
  return lineDiff.diff(oldStr, newStr, options);
}
function tokenize(value, options) {
  if (options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  const retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (let i = 0; i < linesAndNewlines.length; i++) {
    const line = linesAndNewlines[i];
    if (i % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
}

// node_modules/diff/libesm/patch/create.js
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  let optionsObj;
  if (!options) {
    optionsObj = {};
  } else if (typeof options === "function") {
    optionsObj = { callback: options };
  } else {
    optionsObj = options;
  }
  if (typeof optionsObj.context === "undefined") {
    optionsObj.context = 4;
  }
  const context = optionsObj.context;
  if (optionsObj.newlineIsToken) {
    throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  }
  if (!optionsObj.callback) {
    return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));
  } else {
    const { callback } = optionsObj;
    diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), { callback: (diff2) => {
      const patch = diffLinesResultToPatch(diff2);
      callback(patch);
    } }));
  }
  function diffLinesResultToPatch(diff2) {
    if (!diff2) {
      return;
    }
    diff2.push({ value: "", lines: [] });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    const hunks = [];
    let oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    for (let i = 0; i < diff2.length; i++) {
      const current = diff2[i], lines = current.lines || splitLines(current.value);
      current.lines = lines;
      if (current.added || current.removed) {
        if (!oldRangeStart) {
          const prev = diff2[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;
          if (prev) {
            curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }
        for (const line of lines) {
          curRange.push((current.added ? "+" : "-") + line);
        }
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        if (oldRangeStart) {
          if (lines.length <= context * 2 && i < diff2.length - 2) {
            for (const line of contextLines(lines)) {
              curRange.push(line);
            }
          } else {
            const contextSize = Math.min(lines.length, context);
            for (const line of contextLines(lines.slice(0, contextSize))) {
              curRange.push(line);
            }
            const hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    }
    for (const hunk of hunks) {
      for (let i = 0; i < hunk.lines.length; i++) {
        if (hunk.lines[i].endsWith("\n")) {
          hunk.lines[i] = hunk.lines[i].slice(0, -1);
        } else {
          hunk.lines.splice(i + 1, 0, "\\ No newline at end of file");
          i++;
        }
      }
    }
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
}
function formatPatch(patch) {
  if (Array.isArray(patch)) {
    return patch.map(formatPatch).join("\n");
  }
  const ret = [];
  if (patch.oldFileName == patch.newFileName) {
    ret.push("Index: " + patch.oldFileName);
  }
  ret.push("===================================================================");
  ret.push("--- " + patch.oldFileName + (typeof patch.oldHeader === "undefined" ? "" : "	" + patch.oldHeader));
  ret.push("+++ " + patch.newFileName + (typeof patch.newHeader === "undefined" ? "" : "	" + patch.newHeader));
  for (let i = 0; i < patch.hunks.length; i++) {
    const hunk = patch.hunks[i];
    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }
    ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    for (const line of hunk.lines) {
      ret.push(line);
    }
  }
  return ret.join("\n") + "\n";
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (typeof options === "function") {
    options = { callback: options };
  }
  if (!(options === null || options === void 0 ? void 0 : options.callback)) {
    const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
    if (!patchObj) {
      return;
    }
    return formatPatch(patchObj);
  } else {
    const { callback } = options;
    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, Object.assign(Object.assign({}, options), { callback: (patchObj) => {
      if (!patchObj) {
        callback(void 0);
      } else {
        callback(formatPatch(patchObj));
      }
    } }));
  }
}
function splitLines(text) {
  const hasTrailingNl = text.endsWith("\n");
  const result = text.split("\n").map((line) => line + "\n");
  if (hasTrailingNl) {
    result.pop();
  } else {
    result.push(result.pop().slice(0, -1));
  }
  return result;
}

// node_modules/diff2html/lib-esm/types.js
var LineType;
(function(LineType2) {
  LineType2["INSERT"] = "insert";
  LineType2["DELETE"] = "delete";
  LineType2["CONTEXT"] = "context";
})(LineType || (LineType = {}));
var OutputFormatType = {
  LINE_BY_LINE: "line-by-line",
  SIDE_BY_SIDE: "side-by-side"
};
var LineMatchingType = {
  LINES: "lines",
  WORDS: "words",
  NONE: "none"
};
var DiffStyleType = {
  WORD: "word",
  CHAR: "char"
};
var ColorSchemeType;
(function(ColorSchemeType2) {
  ColorSchemeType2["AUTO"] = "auto";
  ColorSchemeType2["DARK"] = "dark";
  ColorSchemeType2["LIGHT"] = "light";
})(ColorSchemeType || (ColorSchemeType = {}));

// node_modules/diff2html/lib-esm/utils.js
var specials = [
  "-",
  "[",
  "]",
  "/",
  "{",
  "}",
  "(",
  ")",
  "*",
  "+",
  "?",
  ".",
  "\\",
  "^",
  "$",
  "|"
];
var regex = RegExp("[" + specials.join("\\") + "]", "g");
function escapeForRegExp(str) {
  return str.replace(regex, "\\$&");
}
function unifyPath(path) {
  return path ? path.replace(/\\/g, "/") : path;
}
function hashCode(text) {
  let i, chr, len;
  let hash = 0;
  for (i = 0, len = text.length; i < len; i++) {
    chr = text.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash;
}

// node_modules/diff2html/lib-esm/diff-parser.js
function getExtension(filename, language) {
  const filenameParts = filename.split(".");
  return filenameParts.length > 1 ? filenameParts[filenameParts.length - 1] : language;
}
function startsWithAny(str, prefixes) {
  return prefixes.reduce((startsWith, prefix) => startsWith || str.startsWith(prefix), false);
}
var baseDiffFilenamePrefixes = ["a/", "b/", "i/", "w/", "c/", "o/"];
function getFilename(line, linePrefix, extraPrefix) {
  const prefixes = extraPrefix !== void 0 ? [...baseDiffFilenamePrefixes, extraPrefix] : baseDiffFilenamePrefixes;
  const FilenameRegExp = linePrefix ? new RegExp(`^${escapeForRegExp(linePrefix)} "?(.+?)"?$`) : new RegExp('^"?(.+?)"?$');
  const [, filename = ""] = FilenameRegExp.exec(line) || [];
  const matchingPrefix = prefixes.find((p) => filename.indexOf(p) === 0);
  const fnameWithoutPrefix = matchingPrefix ? filename.slice(matchingPrefix.length) : filename;
  return fnameWithoutPrefix.replace(/\s+\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:\.\d+)? [+-]\d{4}.*$/, "");
}
function getSrcFilename(line, srcPrefix) {
  return getFilename(line, "---", srcPrefix);
}
function getDstFilename(line, dstPrefix) {
  return getFilename(line, "+++", dstPrefix);
}
function parse(diffInput, config = {}) {
  const files = [];
  let currentFile = null;
  let currentBlock = null;
  let oldLine = null;
  let oldLine2 = null;
  let newLine = null;
  let possibleOldName = null;
  let possibleNewName = null;
  const oldFileNameHeader = "--- ";
  const newFileNameHeader = "+++ ";
  const hunkHeaderPrefix = "@@";
  const oldMode = /^old mode (\d{6})/;
  const newMode = /^new mode (\d{6})/;
  const deletedFileMode = /^deleted file mode (\d{6})/;
  const newFileMode = /^new file mode (\d{6})/;
  const copyFrom = /^copy from "?(.+)"?/;
  const copyTo = /^copy to "?(.+)"?/;
  const renameFrom = /^rename from "?(.+)"?/;
  const renameTo = /^rename to "?(.+)"?/;
  const similarityIndex = /^similarity index (\d+)%/;
  const dissimilarityIndex = /^dissimilarity index (\d+)%/;
  const index = /^index ([\da-z]+)\.\.([\da-z]+)\s*(\d{6})?/;
  const binaryFiles = /^Binary files (.*) and (.*) differ/;
  const binaryDiff = /^GIT binary patch/;
  const combinedIndex = /^index ([\da-z]+),([\da-z]+)\.\.([\da-z]+)/;
  const combinedMode = /^mode (\d{6}),(\d{6})\.\.(\d{6})/;
  const combinedNewFile = /^new file mode (\d{6})/;
  const combinedDeletedFile = /^deleted file mode (\d{6}),(\d{6})/;
  const diffLines2 = diffInput.replace(/\\ No newline at end of file/g, "").replace(/\r\n?/g, "\n").split("\n");
  function saveBlock() {
    if (currentBlock !== null && currentFile !== null) {
      currentFile.blocks.push(currentBlock);
      currentBlock = null;
    }
  }
  function saveFile() {
    if (currentFile !== null) {
      if (!currentFile.oldName && possibleOldName !== null) {
        currentFile.oldName = possibleOldName;
      }
      if (!currentFile.newName && possibleNewName !== null) {
        currentFile.newName = possibleNewName;
      }
      if (currentFile.newName) {
        files.push(currentFile);
        currentFile = null;
      }
    }
    possibleOldName = null;
    possibleNewName = null;
  }
  function startFile() {
    saveBlock();
    saveFile();
    currentFile = {
      blocks: [],
      deletedLines: 0,
      addedLines: 0
    };
  }
  function startBlock(line) {
    saveBlock();
    let values;
    if (currentFile !== null) {
      if (values = /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@.*/.exec(line)) {
        currentFile.isCombined = false;
        oldLine = parseInt(values[1], 10);
        newLine = parseInt(values[2], 10);
      } else if (values = /^@@@ -(\d+)(?:,\d+)? -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@@.*/.exec(line)) {
        currentFile.isCombined = true;
        oldLine = parseInt(values[1], 10);
        oldLine2 = parseInt(values[2], 10);
        newLine = parseInt(values[3], 10);
      } else {
        if (line.startsWith(hunkHeaderPrefix)) {
          console.error("Failed to parse lines, starting in 0!");
        }
        oldLine = 0;
        newLine = 0;
        currentFile.isCombined = false;
      }
    }
    currentBlock = {
      lines: [],
      oldStartLine: oldLine,
      oldStartLine2: oldLine2,
      newStartLine: newLine,
      header: line
    };
  }
  function createLine(line) {
    if (currentFile === null || currentBlock === null || oldLine === null || newLine === null)
      return;
    const currentLine = {
      content: line
    };
    const addedPrefixes = currentFile.isCombined ? ["+ ", " +", "++"] : ["+"];
    const deletedPrefixes = currentFile.isCombined ? ["- ", " -", "--"] : ["-"];
    if (startsWithAny(line, addedPrefixes)) {
      currentFile.addedLines++;
      currentLine.type = LineType.INSERT;
      currentLine.oldNumber = void 0;
      currentLine.newNumber = newLine++;
    } else if (startsWithAny(line, deletedPrefixes)) {
      currentFile.deletedLines++;
      currentLine.type = LineType.DELETE;
      currentLine.oldNumber = oldLine++;
      currentLine.newNumber = void 0;
    } else {
      currentLine.type = LineType.CONTEXT;
      currentLine.oldNumber = oldLine++;
      currentLine.newNumber = newLine++;
    }
    currentBlock.lines.push(currentLine);
  }
  function existHunkHeader(line, lineIdx) {
    let idx = lineIdx;
    while (idx < diffLines2.length - 3) {
      if (line.startsWith("diff")) {
        return false;
      }
      if (diffLines2[idx].startsWith(oldFileNameHeader) && diffLines2[idx + 1].startsWith(newFileNameHeader) && diffLines2[idx + 2].startsWith(hunkHeaderPrefix)) {
        return true;
      }
      idx++;
    }
    return false;
  }
  diffLines2.forEach((line, lineIndex) => {
    if (!line || line.startsWith("*")) {
      return;
    }
    let values;
    const prevLine = diffLines2[lineIndex - 1];
    const nxtLine = diffLines2[lineIndex + 1];
    const afterNxtLine = diffLines2[lineIndex + 2];
    if (line.startsWith("diff --git") || line.startsWith("diff --combined")) {
      startFile();
      const gitDiffStart = /^diff --git "?([a-ciow]\/.+)"? "?([a-ciow]\/.+)"?/;
      if (values = gitDiffStart.exec(line)) {
        possibleOldName = getFilename(values[1], void 0, config.dstPrefix);
        possibleNewName = getFilename(values[2], void 0, config.srcPrefix);
      }
      if (currentFile === null) {
        throw new Error("Where is my file !!!");
      }
      currentFile.isGitDiff = true;
      return;
    }
    if (line.startsWith("Binary files") && !(currentFile === null || currentFile === void 0 ? void 0 : currentFile.isGitDiff)) {
      startFile();
      const unixDiffBinaryStart = /^Binary files "?([a-ciow]\/.+)"? and "?([a-ciow]\/.+)"? differ/;
      if (values = unixDiffBinaryStart.exec(line)) {
        possibleOldName = getFilename(values[1], void 0, config.dstPrefix);
        possibleNewName = getFilename(values[2], void 0, config.srcPrefix);
      }
      if (currentFile === null) {
        throw new Error("Where is my file !!!");
      }
      currentFile.isBinary = true;
      return;
    }
    if (!currentFile || !currentFile.isGitDiff && currentFile && line.startsWith(oldFileNameHeader) && nxtLine.startsWith(newFileNameHeader) && afterNxtLine.startsWith(hunkHeaderPrefix)) {
      startFile();
    }
    if (currentFile === null || currentFile === void 0 ? void 0 : currentFile.isTooBig) {
      return;
    }
    if (currentFile && (typeof config.diffMaxChanges === "number" && currentFile.addedLines + currentFile.deletedLines > config.diffMaxChanges || typeof config.diffMaxLineLength === "number" && line.length > config.diffMaxLineLength)) {
      currentFile.isTooBig = true;
      currentFile.addedLines = 0;
      currentFile.deletedLines = 0;
      currentFile.blocks = [];
      currentBlock = null;
      const message = typeof config.diffTooBigMessage === "function" ? config.diffTooBigMessage(files.length) : "Diff too big to be displayed";
      startBlock(message);
      return;
    }
    if (line.startsWith(oldFileNameHeader) && nxtLine.startsWith(newFileNameHeader) || line.startsWith(newFileNameHeader) && prevLine.startsWith(oldFileNameHeader)) {
      if (currentFile && !currentFile.oldName && line.startsWith("--- ") && (values = getSrcFilename(line, config.srcPrefix))) {
        currentFile.oldName = values;
        currentFile.language = getExtension(currentFile.oldName, currentFile.language);
        return;
      }
      if (currentFile && !currentFile.newName && line.startsWith("+++ ") && (values = getDstFilename(line, config.dstPrefix))) {
        currentFile.newName = values;
        currentFile.language = getExtension(currentFile.newName, currentFile.language);
        return;
      }
    }
    if (currentFile && (line.startsWith(hunkHeaderPrefix) || currentFile.isGitDiff && currentFile.oldName && currentFile.newName && !currentBlock)) {
      startBlock(line);
      return;
    }
    if (currentBlock && (line.startsWith("+") || line.startsWith("-") || line.startsWith(" "))) {
      createLine(line);
      return;
    }
    const doesNotExistHunkHeader = !existHunkHeader(line, lineIndex);
    if (currentFile === null) {
      throw new Error("Where is my file !!!");
    }
    if (values = oldMode.exec(line)) {
      currentFile.oldMode = values[1];
    } else if (values = newMode.exec(line)) {
      currentFile.newMode = values[1];
    } else if (values = deletedFileMode.exec(line)) {
      currentFile.deletedFileMode = values[1];
      currentFile.isDeleted = true;
    } else if (values = newFileMode.exec(line)) {
      currentFile.newFileMode = values[1];
      currentFile.isNew = true;
    } else if (values = copyFrom.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.oldName = values[1];
      }
      currentFile.isCopy = true;
    } else if (values = copyTo.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.newName = values[1];
      }
      currentFile.isCopy = true;
    } else if (values = renameFrom.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.oldName = values[1];
      }
      currentFile.isRename = true;
    } else if (values = renameTo.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.newName = values[1];
      }
      currentFile.isRename = true;
    } else if (values = binaryFiles.exec(line)) {
      currentFile.isBinary = true;
      currentFile.oldName = getFilename(values[1], void 0, config.srcPrefix);
      currentFile.newName = getFilename(values[2], void 0, config.dstPrefix);
      startBlock("Binary file");
    } else if (binaryDiff.test(line)) {
      currentFile.isBinary = true;
      startBlock(line);
    } else if (values = similarityIndex.exec(line)) {
      currentFile.unchangedPercentage = parseInt(values[1], 10);
    } else if (values = dissimilarityIndex.exec(line)) {
      currentFile.changedPercentage = parseInt(values[1], 10);
    } else if (values = index.exec(line)) {
      currentFile.checksumBefore = values[1];
      currentFile.checksumAfter = values[2];
      if (values[3])
        currentFile.mode = values[3];
    } else if (values = combinedIndex.exec(line)) {
      currentFile.checksumBefore = [values[2], values[3]];
      currentFile.checksumAfter = values[1];
    } else if (values = combinedMode.exec(line)) {
      currentFile.oldMode = [values[2], values[3]];
      currentFile.newMode = values[1];
    } else if (values = combinedNewFile.exec(line)) {
      currentFile.newFileMode = values[1];
      currentFile.isNew = true;
    } else if (values = combinedDeletedFile.exec(line)) {
      currentFile.deletedFileMode = values[1];
      currentFile.isDeleted = true;
    }
  });
  saveBlock();
  saveFile();
  return files;
}

// node_modules/diff2html/node_modules/diff/lib/index.mjs
function Diff2() {
}
Diff2.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    var self2 = this;
    function done(value) {
      value = self2.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString, options);
    newString = this.castInput(newString, options);
    oldString = this.removeEmpty(this.tokenize(oldString, options));
    newString = this.removeEmpty(this.tokenize(newString, options));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(buildValues(self2, bestPath[0].lastComponent, newString, oldString, self2.useLongestToken));
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = self2.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = self2.addToPath(removePath, false, true, 1, options);
        }
        newPos = self2.extractCommon(basePath, newString, oldString, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self2, basePath.lastComponent, newString, oldString, self2.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path, added, removed, oldPosInc, options) {
    var last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath, options) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = {
          count: 1,
          previousComponent: basePath.lastComponent,
          added: false,
          removed: false
        };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent,
        added: false,
        removed: false
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize2(value) {
    return Array.from(value);
  },
  join: function join(chars) {
    return chars.join("");
  },
  postProcess: function postProcess(changeObjects) {
    return changeObjects;
  }
};
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff2.join(value);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
    }
  }
  return components;
}
var characterDiff = new Diff2();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
function longestCommonPrefix(str1, str2) {
  var i;
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
function longestCommonSuffix(str1, str2) {
  var i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
function replacePrefix(string, oldPrefix, newPrefix) {
  if (string.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error("string ".concat(JSON.stringify(string), " doesn't start with prefix ").concat(JSON.stringify(oldPrefix), "; this is a bug"));
  }
  return newPrefix + string.slice(oldPrefix.length);
}
function replaceSuffix(string, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string + newSuffix;
  }
  if (string.slice(-oldSuffix.length) != oldSuffix) {
    throw Error("string ".concat(JSON.stringify(string), " doesn't end with suffix ").concat(JSON.stringify(oldSuffix), "; this is a bug"));
  }
  return string.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string, oldPrefix) {
  return replacePrefix(string, oldPrefix, "");
}
function removeSuffix(string, oldSuffix) {
  return replaceSuffix(string, oldSuffix, "");
}
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
function overlapCount(a, b) {
  var startA = 0;
  if (a.length > b.length) {
    startA = a.length - b.length;
  }
  var endB = b.length;
  if (a.length < b.length) {
    endB = a.length;
  }
  var map = Array(endB);
  var k = 0;
  map[0] = 0;
  for (var j = 1; j < endB; j++) {
    if (b[j] == b[k]) {
      map[j] = map[k];
    } else {
      map[j] = k;
    }
    while (k > 0 && b[j] != b[k]) {
      k = map[k];
    }
    if (b[j] == b[k]) {
      k++;
    }
  }
  k = 0;
  for (var i = startA; i < a.length; i++) {
    while (k > 0 && a[i] != b[k]) {
      k = map[k];
    }
    if (a[i] == b[k]) {
      k++;
    }
  }
  return k;
}
var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp("[".concat(extendedWordChars, "]+|\\s+|[^").concat(extendedWordChars, "]"), "ug");
var wordDiff = new Diff2();
wordDiff.equals = function(left, right, options) {
  if (options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left.trim() === right.trim();
};
wordDiff.tokenize = function(value) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var parts;
  if (options.intlSegmenter) {
    if (options.intlSegmenter.resolvedOptions().granularity != "word") {
      throw new Error('The segmenter passed must have a granularity of "word"');
    }
    parts = Array.from(options.intlSegmenter.segment(value), function(segment) {
      return segment.segment;
    });
  } else {
    parts = value.match(tokenizeIncludingWhitespace) || [];
  }
  var tokens = [];
  var prevPart = null;
  parts.forEach(function(part) {
    if (/\s/.test(part)) {
      if (prevPart == null) {
        tokens.push(part);
      } else {
        tokens.push(tokens.pop() + part);
      }
    } else if (/\s/.test(prevPart)) {
      if (tokens[tokens.length - 1] == prevPart) {
        tokens.push(tokens.pop() + part);
      } else {
        tokens.push(prevPart + part);
      }
    } else {
      tokens.push(part);
    }
    prevPart = part;
  });
  return tokens;
};
wordDiff.join = function(tokens) {
  return tokens.map(function(token, i) {
    if (i == 0) {
      return token;
    } else {
      return token.replace(/^\s+/, "");
    }
  }).join("");
};
wordDiff.postProcess = function(changes, options) {
  if (!changes || options.oneChangePerToken) {
    return changes;
  }
  var lastKeep = null;
  var insertion = null;
  var deletion = null;
  changes.forEach(function(change) {
    if (change.added) {
      insertion = change;
    } else if (change.removed) {
      deletion = change;
    } else {
      if (insertion || deletion) {
        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
      }
      lastKeep = change;
      insertion = null;
      deletion = null;
    }
  });
  if (insertion || deletion) {
    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
  }
  return changes;
};
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    var oldWsPrefix = deletion.value.match(/^\s*/)[0];
    var oldWsSuffix = deletion.value.match(/\s*$/)[0];
    var newWsPrefix = insertion.value.match(/^\s*/)[0];
    var newWsSuffix = insertion.value.match(/\s*$/)[0];
    if (startKeep) {
      var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      insertion.value = insertion.value.replace(/^\s*/, "");
    }
    if (endKeep) {
      endKeep.value = endKeep.value.replace(/^\s*/, "");
    }
  } else if (startKeep && endKeep) {
    var newWsFull = endKeep.value.match(/^\s*/)[0], delWsStart = deletion.value.match(/^\s*/)[0], delWsEnd = deletion.value.match(/\s*$/)[0];
    var newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    var endKeepWsPrefix = endKeep.value.match(/^\s*/)[0];
    var deletionWsSuffix = deletion.value.match(/\s*$/)[0];
    var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    var startKeepWsSuffix = startKeep.value.match(/\s*$/)[0];
    var deletionWsPrefix = deletion.value.match(/^\s*/)[0];
    var _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, _overlap);
  }
}
var wordWithSpaceDiff = new Diff2();
wordWithSpaceDiff.tokenize = function(value) {
  var regex2 = new RegExp("(\\r?\\n)|[".concat(extendedWordChars, "]+|[^\\S\\n\\r]+|[^").concat(extendedWordChars, "]"), "ug");
  return value.match(regex2) || [];
};
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordWithSpaceDiff.diff(oldStr, newStr, options);
}
var lineDiff2 = new Diff2();
lineDiff2.tokenize = function(value, options) {
  if (options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];
    if (i % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
};
lineDiff2.equals = function(left, right, options) {
  if (options.ignoreWhitespace) {
    if (!options.newlineIsToken || !left.includes("\n")) {
      left = left.trim();
    }
    if (!options.newlineIsToken || !right.includes("\n")) {
      right = right.trim();
    }
  } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
    if (left.endsWith("\n")) {
      left = left.slice(0, -1);
    }
    if (right.endsWith("\n")) {
      right = right.slice(0, -1);
    }
  }
  return Diff2.prototype.equals.call(this, left, right, options);
};
var sentenceDiff = new Diff2();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff2();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var jsonDiff = new Diff2();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff2.tokenize;
jsonDiff.castInput = function(value, options) {
  var undefinedReplacement = options.undefinedReplacement, _options$stringifyRep = options.stringifyReplacer, stringifyReplacer = _options$stringifyRep === void 0 ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _options$stringifyRep;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right, options) {
  return Diff2.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options);
};
function canonicalize(obj, stack, replacementStack, replacer, key2) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key2, obj);
  }
  var i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === Object.prototype.toString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key2);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, _key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff2();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};

// node_modules/diff2html/lib-esm/rematch.js
function levenshtein(a, b) {
  if (a.length === 0) {
    return b.length;
  }
  if (b.length === 0) {
    return a.length;
  }
  const matrix = [];
  let i;
  for (i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }
  let j;
  for (j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (i = 1; i <= b.length; i++) {
    for (j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
      }
    }
  }
  return matrix[b.length][a.length];
}
function newDistanceFn(str) {
  return (x, y) => {
    const xValue = str(x).trim();
    const yValue = str(y).trim();
    const lev = levenshtein(xValue, yValue);
    return lev / (xValue.length + yValue.length);
  };
}
function newMatcherFn(distance2) {
  function findBestMatch(a, b, cache = /* @__PURE__ */ new Map()) {
    let bestMatchDist = Infinity;
    let bestMatch;
    for (let i = 0; i < a.length; ++i) {
      for (let j = 0; j < b.length; ++j) {
        const cacheKey = JSON.stringify([a[i], b[j]]);
        let md;
        if (!(cache.has(cacheKey) && (md = cache.get(cacheKey)))) {
          md = distance2(a[i], b[j]);
          cache.set(cacheKey, md);
        }
        if (md < bestMatchDist) {
          bestMatchDist = md;
          bestMatch = { indexA: i, indexB: j, score: bestMatchDist };
        }
      }
    }
    return bestMatch;
  }
  function group(a, b, level = 0, cache = /* @__PURE__ */ new Map()) {
    const bm = findBestMatch(a, b, cache);
    if (!bm || a.length + b.length < 3) {
      return [[a, b]];
    }
    const a1 = a.slice(0, bm.indexA);
    const b1 = b.slice(0, bm.indexB);
    const aMatch = [a[bm.indexA]];
    const bMatch = [b[bm.indexB]];
    const tailA = bm.indexA + 1;
    const tailB = bm.indexB + 1;
    const a2 = a.slice(tailA);
    const b2 = b.slice(tailB);
    const group1 = group(a1, b1, level + 1, cache);
    const groupMatch = group(aMatch, bMatch, level + 1, cache);
    const group2 = group(a2, b2, level + 1, cache);
    let result = groupMatch;
    if (bm.indexA > 0 || bm.indexB > 0) {
      result = group1.concat(result);
    }
    if (a.length > tailA || b.length > tailB) {
      result = result.concat(group2);
    }
    return result;
  }
  return group;
}

// node_modules/diff2html/lib-esm/render-utils.js
var CSSLineClass = {
  INSERTS: "d2h-ins",
  DELETES: "d2h-del",
  CONTEXT: "d2h-cntx",
  INFO: "d2h-info",
  INSERT_CHANGES: "d2h-ins d2h-change",
  DELETE_CHANGES: "d2h-del d2h-change"
};
var defaultRenderConfig = {
  matching: LineMatchingType.NONE,
  matchWordsThreshold: 0.25,
  maxLineLengthHighlight: 1e4,
  diffStyle: DiffStyleType.WORD,
  colorScheme: ColorSchemeType.LIGHT
};
var separator = "/";
var distance = newDistanceFn((change) => change.value);
var matcher = newMatcherFn(distance);
function isDevNullName(name) {
  return name.indexOf("dev/null") !== -1;
}
function removeInsElements(line) {
  return line.replace(/(<ins[^>]*>((.|\n)*?)<\/ins>)/g, "");
}
function removeDelElements(line) {
  return line.replace(/(<del[^>]*>((.|\n)*?)<\/del>)/g, "");
}
function toCSSClass(lineType) {
  switch (lineType) {
    case LineType.CONTEXT:
      return CSSLineClass.CONTEXT;
    case LineType.INSERT:
      return CSSLineClass.INSERTS;
    case LineType.DELETE:
      return CSSLineClass.DELETES;
  }
}
function colorSchemeToCss(colorScheme) {
  switch (colorScheme) {
    case ColorSchemeType.DARK:
      return "d2h-dark-color-scheme";
    case ColorSchemeType.AUTO:
      return "d2h-auto-color-scheme";
    case ColorSchemeType.LIGHT:
    default:
      return "d2h-light-color-scheme";
  }
}
function prefixLength(isCombined) {
  return isCombined ? 2 : 1;
}
function escapeForHtml(str) {
  return str.slice(0).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function deconstructLine(line, isCombined, escape = true) {
  const indexToSplit = prefixLength(isCombined);
  return {
    prefix: line.substring(0, indexToSplit),
    content: escape ? escapeForHtml(line.substring(indexToSplit)) : line.substring(indexToSplit)
  };
}
function filenameDiff(file) {
  const oldFilename = unifyPath(file.oldName);
  const newFilename = unifyPath(file.newName);
  if (oldFilename !== newFilename && !isDevNullName(oldFilename) && !isDevNullName(newFilename)) {
    const prefixPaths = [];
    const suffixPaths = [];
    const oldFilenameParts = oldFilename.split(separator);
    const newFilenameParts = newFilename.split(separator);
    const oldFilenamePartsSize = oldFilenameParts.length;
    const newFilenamePartsSize = newFilenameParts.length;
    let i = 0;
    let j = oldFilenamePartsSize - 1;
    let k = newFilenamePartsSize - 1;
    while (i < j && i < k) {
      if (oldFilenameParts[i] === newFilenameParts[i]) {
        prefixPaths.push(newFilenameParts[i]);
        i += 1;
      } else {
        break;
      }
    }
    while (j > i && k > i) {
      if (oldFilenameParts[j] === newFilenameParts[k]) {
        suffixPaths.unshift(newFilenameParts[k]);
        j -= 1;
        k -= 1;
      } else {
        break;
      }
    }
    const finalPrefix = prefixPaths.join(separator);
    const finalSuffix = suffixPaths.join(separator);
    const oldRemainingPath = oldFilenameParts.slice(i, j + 1).join(separator);
    const newRemainingPath = newFilenameParts.slice(i, k + 1).join(separator);
    if (finalPrefix.length && finalSuffix.length) {
      return finalPrefix + separator + "{" + oldRemainingPath + " \u2192 " + newRemainingPath + "}" + separator + finalSuffix;
    } else if (finalPrefix.length) {
      return finalPrefix + separator + "{" + oldRemainingPath + " \u2192 " + newRemainingPath + "}";
    } else if (finalSuffix.length) {
      return "{" + oldRemainingPath + " \u2192 " + newRemainingPath + "}" + separator + finalSuffix;
    }
    return oldFilename + " \u2192 " + newFilename;
  } else if (!isDevNullName(newFilename)) {
    return newFilename;
  } else {
    return oldFilename;
  }
}
function getHtmlId(file) {
  return `d2h-${hashCode(filenameDiff(file)).toString().slice(-6)}`;
}
function getFileIcon(file) {
  let templateName = "file-changed";
  if (file.isRename) {
    templateName = "file-renamed";
  } else if (file.isCopy) {
    templateName = "file-renamed";
  } else if (file.isNew) {
    templateName = "file-added";
  } else if (file.isDeleted) {
    templateName = "file-deleted";
  } else if (file.newName !== file.oldName) {
    templateName = "file-renamed";
  }
  return templateName;
}
function diffHighlight(diffLine1, diffLine2, isCombined, config = {}) {
  const { matching, maxLineLengthHighlight, matchWordsThreshold, diffStyle } = Object.assign(Object.assign({}, defaultRenderConfig), config);
  const line1 = deconstructLine(diffLine1, isCombined, false);
  const line2 = deconstructLine(diffLine2, isCombined, false);
  if (line1.content.length > maxLineLengthHighlight || line2.content.length > maxLineLengthHighlight) {
    return {
      oldLine: {
        prefix: line1.prefix,
        content: escapeForHtml(line1.content)
      },
      newLine: {
        prefix: line2.prefix,
        content: escapeForHtml(line2.content)
      }
    };
  }
  const diff2 = diffStyle === "char" ? diffChars(line1.content, line2.content) : diffWordsWithSpace(line1.content, line2.content);
  const changedWords = [];
  if (diffStyle === "word" && matching === "words") {
    const removed = diff2.filter((element) => element.removed);
    const added = diff2.filter((element) => element.added);
    const chunks = matcher(added, removed);
    chunks.forEach((chunk) => {
      if (chunk[0].length === 1 && chunk[1].length === 1) {
        const dist = distance(chunk[0][0], chunk[1][0]);
        if (dist < matchWordsThreshold) {
          changedWords.push(chunk[0][0]);
          changedWords.push(chunk[1][0]);
        }
      }
    });
  }
  const highlightedLine = diff2.reduce((highlightedLine2, part) => {
    const elemType = part.added ? "ins" : part.removed ? "del" : null;
    const addClass = changedWords.indexOf(part) > -1 ? ' class="d2h-change"' : "";
    const escapedValue = escapeForHtml(part.value);
    return elemType !== null ? `${highlightedLine2}<${elemType}${addClass}>${escapedValue}</${elemType}>` : `${highlightedLine2}${escapedValue}`;
  }, "");
  return {
    oldLine: {
      prefix: line1.prefix,
      content: removeInsElements(highlightedLine)
    },
    newLine: {
      prefix: line2.prefix,
      content: removeDelElements(highlightedLine)
    }
  };
}

// node_modules/diff2html/lib-esm/file-list-renderer.js
var baseTemplatesPath = "file-summary";
var iconsBaseTemplatesPath = "icon";
var defaultFileListRendererConfig = {
  colorScheme: defaultRenderConfig.colorScheme
};
var FileListRenderer = class {
  constructor(hoganUtils, config = {}) {
    this.hoganUtils = hoganUtils;
    this.config = Object.assign(Object.assign({}, defaultFileListRendererConfig), config);
  }
  render(diffFiles) {
    const files = diffFiles.map((file) => this.hoganUtils.render(baseTemplatesPath, "line", {
      fileHtmlId: getHtmlId(file),
      oldName: file.oldName,
      newName: file.newName,
      fileName: filenameDiff(file),
      deletedLines: "-" + file.deletedLines,
      addedLines: "+" + file.addedLines
    }, {
      fileIcon: this.hoganUtils.template(iconsBaseTemplatesPath, getFileIcon(file))
    })).join("\n");
    return this.hoganUtils.render(baseTemplatesPath, "wrapper", {
      colorScheme: colorSchemeToCss(this.config.colorScheme),
      filesNumber: diffFiles.length,
      files
    });
  }
};

// node_modules/diff2html/lib-esm/line-by-line-renderer.js
var defaultLineByLineRendererConfig = Object.assign(Object.assign({}, defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: 2500, maxLineSizeInBlockForComparison: 200 });
var genericTemplatesPath = "generic";
var baseTemplatesPath2 = "line-by-line";
var iconsBaseTemplatesPath2 = "icon";
var tagsBaseTemplatesPath = "tag";
var LineByLineRenderer = class {
  constructor(hoganUtils, config = {}) {
    this.hoganUtils = hoganUtils;
    this.config = Object.assign(Object.assign({}, defaultLineByLineRendererConfig), config);
  }
  render(diffFiles) {
    const diffsHtml = diffFiles.map((file) => {
      let diffs;
      if (file.blocks.length) {
        diffs = this.generateFileHtml(file);
      } else {
        diffs = this.generateEmptyDiff();
      }
      return this.makeFileDiffHtml(file, diffs);
    }).join("\n");
    return this.hoganUtils.render(genericTemplatesPath, "wrapper", {
      colorScheme: colorSchemeToCss(this.config.colorScheme),
      content: diffsHtml
    });
  }
  makeFileDiffHtml(file, diffs) {
    if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === 0)
      return "";
    const fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath2, "file-diff");
    const filePathTemplate = this.hoganUtils.template(genericTemplatesPath, "file-path");
    const fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath2, "file");
    const fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath, getFileIcon(file));
    return fileDiffTemplate.render({
      file,
      fileHtmlId: getHtmlId(file),
      diffs,
      filePath: filePathTemplate.render({
        fileDiffName: filenameDiff(file)
      }, {
        fileIcon: fileIconTemplate,
        fileTag: fileTagTemplate
      })
    });
  }
  generateEmptyDiff() {
    return this.hoganUtils.render(genericTemplatesPath, "empty-diff", {
      contentClass: "d2h-code-line",
      CSSLineClass
    });
  }
  generateFileHtml(file) {
    const matcher2 = newMatcherFn(newDistanceFn((e) => deconstructLine(e.content, file.isCombined).content));
    return file.blocks.map((block) => {
      let lines = this.hoganUtils.render(genericTemplatesPath, "block-header", {
        CSSLineClass,
        blockHeader: file.isTooBig ? block.header : escapeForHtml(block.header),
        lineClass: "d2h-code-linenumber",
        contentClass: "d2h-code-line"
      });
      this.applyLineGroupping(block).forEach(([contextLines, oldLines, newLines]) => {
        if (oldLines.length && newLines.length && !contextLines.length) {
          this.applyRematchMatching(oldLines, newLines, matcher2).map(([oldLines2, newLines2]) => {
            const { left, right } = this.processChangedLines(file, file.isCombined, oldLines2, newLines2);
            lines += left;
            lines += right;
          });
        } else if (contextLines.length) {
          contextLines.forEach((line) => {
            const { prefix, content } = deconstructLine(line.content, file.isCombined);
            lines += this.generateSingleLineHtml(file, {
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              oldNumber: line.oldNumber,
              newNumber: line.newNumber
            });
          });
        } else if (oldLines.length || newLines.length) {
          const { left, right } = this.processChangedLines(file, file.isCombined, oldLines, newLines);
          lines += left;
          lines += right;
        } else {
          console.error("Unknown state reached while processing groups of lines", contextLines, oldLines, newLines);
        }
      });
      return lines;
    }).join("\n");
  }
  applyLineGroupping(block) {
    const blockLinesGroups = [];
    let oldLines = [];
    let newLines = [];
    for (let i = 0; i < block.lines.length; i++) {
      const diffLine = block.lines[i];
      if (diffLine.type !== LineType.INSERT && newLines.length || diffLine.type === LineType.CONTEXT && oldLines.length > 0) {
        blockLinesGroups.push([[], oldLines, newLines]);
        oldLines = [];
        newLines = [];
      }
      if (diffLine.type === LineType.CONTEXT) {
        blockLinesGroups.push([[diffLine], [], []]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length === 0) {
        blockLinesGroups.push([[], [], [diffLine]]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length > 0) {
        newLines.push(diffLine);
      } else if (diffLine.type === LineType.DELETE) {
        oldLines.push(diffLine);
      }
    }
    if (oldLines.length || newLines.length) {
      blockLinesGroups.push([[], oldLines, newLines]);
      oldLines = [];
      newLines = [];
    }
    return blockLinesGroups;
  }
  applyRematchMatching(oldLines, newLines, matcher2) {
    const comparisons = oldLines.length * newLines.length;
    const maxLineSizeInBlock = Math.max.apply(null, [0].concat(oldLines.concat(newLines).map((elem) => elem.content.length)));
    const doMatching = comparisons < this.config.matchingMaxComparisons && maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison && (this.config.matching === "lines" || this.config.matching === "words");
    return doMatching ? matcher2(oldLines, newLines) : [[oldLines, newLines]];
  }
  processChangedLines(file, isCombined, oldLines, newLines) {
    const fileHtml = {
      right: "",
      left: ""
    };
    const maxLinesNumber = Math.max(oldLines.length, newLines.length);
    for (let i = 0; i < maxLinesNumber; i++) {
      const oldLine = oldLines[i];
      const newLine = newLines[i];
      const diff2 = oldLine !== void 0 && newLine !== void 0 ? diffHighlight(oldLine.content, newLine.content, isCombined, this.config) : void 0;
      const preparedOldLine = oldLine !== void 0 && oldLine.oldNumber !== void 0 ? Object.assign(Object.assign({}, diff2 !== void 0 ? {
        prefix: diff2.oldLine.prefix,
        content: diff2.oldLine.content,
        type: CSSLineClass.DELETE_CHANGES
      } : Object.assign(Object.assign({}, deconstructLine(oldLine.content, isCombined)), { type: toCSSClass(oldLine.type) })), { oldNumber: oldLine.oldNumber, newNumber: oldLine.newNumber }) : void 0;
      const preparedNewLine = newLine !== void 0 && newLine.newNumber !== void 0 ? Object.assign(Object.assign({}, diff2 !== void 0 ? {
        prefix: diff2.newLine.prefix,
        content: diff2.newLine.content,
        type: CSSLineClass.INSERT_CHANGES
      } : Object.assign(Object.assign({}, deconstructLine(newLine.content, isCombined)), { type: toCSSClass(newLine.type) })), { oldNumber: newLine.oldNumber, newNumber: newLine.newNumber }) : void 0;
      const { left, right } = this.generateLineHtml(file, preparedOldLine, preparedNewLine);
      fileHtml.left += left;
      fileHtml.right += right;
    }
    return fileHtml;
  }
  generateLineHtml(file, oldLine, newLine) {
    return {
      left: this.generateSingleLineHtml(file, oldLine),
      right: this.generateSingleLineHtml(file, newLine)
    };
  }
  generateSingleLineHtml(file, line) {
    if (line === void 0)
      return "";
    const lineNumberHtml = this.hoganUtils.render(baseTemplatesPath2, "numbers", {
      oldNumber: line.oldNumber || "",
      newNumber: line.newNumber || ""
    });
    return this.hoganUtils.render(genericTemplatesPath, "line", {
      type: line.type,
      lineClass: "d2h-code-linenumber",
      contentClass: "d2h-code-line",
      prefix: line.prefix === " " ? "&nbsp;" : line.prefix,
      content: line.content,
      lineNumber: lineNumberHtml,
      line,
      file
    });
  }
};

// node_modules/diff2html/lib-esm/side-by-side-renderer.js
var defaultSideBySideRendererConfig = Object.assign(Object.assign({}, defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: 2500, maxLineSizeInBlockForComparison: 200 });
var genericTemplatesPath2 = "generic";
var baseTemplatesPath3 = "side-by-side";
var iconsBaseTemplatesPath3 = "icon";
var tagsBaseTemplatesPath2 = "tag";
var SideBySideRenderer = class {
  constructor(hoganUtils, config = {}) {
    this.hoganUtils = hoganUtils;
    this.config = Object.assign(Object.assign({}, defaultSideBySideRendererConfig), config);
  }
  render(diffFiles) {
    const diffsHtml = diffFiles.map((file) => {
      let diffs;
      if (file.blocks.length) {
        diffs = this.generateFileHtml(file);
      } else {
        diffs = this.generateEmptyDiff();
      }
      return this.makeFileDiffHtml(file, diffs);
    }).join("\n");
    return this.hoganUtils.render(genericTemplatesPath2, "wrapper", {
      colorScheme: colorSchemeToCss(this.config.colorScheme),
      content: diffsHtml
    });
  }
  makeFileDiffHtml(file, diffs) {
    if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === 0)
      return "";
    const fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath3, "file-diff");
    const filePathTemplate = this.hoganUtils.template(genericTemplatesPath2, "file-path");
    const fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath3, "file");
    const fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath2, getFileIcon(file));
    return fileDiffTemplate.render({
      file,
      fileHtmlId: getHtmlId(file),
      diffs,
      filePath: filePathTemplate.render({
        fileDiffName: filenameDiff(file)
      }, {
        fileIcon: fileIconTemplate,
        fileTag: fileTagTemplate
      })
    });
  }
  generateEmptyDiff() {
    return {
      right: "",
      left: this.hoganUtils.render(genericTemplatesPath2, "empty-diff", {
        contentClass: "d2h-code-side-line",
        CSSLineClass
      })
    };
  }
  generateFileHtml(file) {
    const matcher2 = newMatcherFn(newDistanceFn((e) => deconstructLine(e.content, file.isCombined).content));
    return file.blocks.map((block) => {
      const fileHtml = {
        left: this.makeHeaderHtml(block.header, file),
        right: this.makeHeaderHtml("")
      };
      this.applyLineGroupping(block).forEach(([contextLines, oldLines, newLines]) => {
        if (oldLines.length && newLines.length && !contextLines.length) {
          this.applyRematchMatching(oldLines, newLines, matcher2).map(([oldLines2, newLines2]) => {
            const { left, right } = this.processChangedLines(file.isCombined, oldLines2, newLines2);
            fileHtml.left += left;
            fileHtml.right += right;
          });
        } else if (contextLines.length) {
          contextLines.forEach((line) => {
            const { prefix, content } = deconstructLine(line.content, file.isCombined);
            const { left, right } = this.generateLineHtml({
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              number: line.oldNumber
            }, {
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              number: line.newNumber
            });
            fileHtml.left += left;
            fileHtml.right += right;
          });
        } else if (oldLines.length || newLines.length) {
          const { left, right } = this.processChangedLines(file.isCombined, oldLines, newLines);
          fileHtml.left += left;
          fileHtml.right += right;
        } else {
          console.error("Unknown state reached while processing groups of lines", contextLines, oldLines, newLines);
        }
      });
      return fileHtml;
    }).reduce((accomulated, html2) => {
      return { left: accomulated.left + html2.left, right: accomulated.right + html2.right };
    }, { left: "", right: "" });
  }
  applyLineGroupping(block) {
    const blockLinesGroups = [];
    let oldLines = [];
    let newLines = [];
    for (let i = 0; i < block.lines.length; i++) {
      const diffLine = block.lines[i];
      if (diffLine.type !== LineType.INSERT && newLines.length || diffLine.type === LineType.CONTEXT && oldLines.length > 0) {
        blockLinesGroups.push([[], oldLines, newLines]);
        oldLines = [];
        newLines = [];
      }
      if (diffLine.type === LineType.CONTEXT) {
        blockLinesGroups.push([[diffLine], [], []]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length === 0) {
        blockLinesGroups.push([[], [], [diffLine]]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length > 0) {
        newLines.push(diffLine);
      } else if (diffLine.type === LineType.DELETE) {
        oldLines.push(diffLine);
      }
    }
    if (oldLines.length || newLines.length) {
      blockLinesGroups.push([[], oldLines, newLines]);
      oldLines = [];
      newLines = [];
    }
    return blockLinesGroups;
  }
  applyRematchMatching(oldLines, newLines, matcher2) {
    const comparisons = oldLines.length * newLines.length;
    const maxLineSizeInBlock = Math.max.apply(null, [0].concat(oldLines.concat(newLines).map((elem) => elem.content.length)));
    const doMatching = comparisons < this.config.matchingMaxComparisons && maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison && (this.config.matching === "lines" || this.config.matching === "words");
    return doMatching ? matcher2(oldLines, newLines) : [[oldLines, newLines]];
  }
  makeHeaderHtml(blockHeader, file) {
    return this.hoganUtils.render(genericTemplatesPath2, "block-header", {
      CSSLineClass,
      blockHeader: (file === null || file === void 0 ? void 0 : file.isTooBig) ? blockHeader : escapeForHtml(blockHeader),
      lineClass: "d2h-code-side-linenumber",
      contentClass: "d2h-code-side-line"
    });
  }
  processChangedLines(isCombined, oldLines, newLines) {
    const fileHtml = {
      right: "",
      left: ""
    };
    const maxLinesNumber = Math.max(oldLines.length, newLines.length);
    for (let i = 0; i < maxLinesNumber; i++) {
      const oldLine = oldLines[i];
      const newLine = newLines[i];
      const diff2 = oldLine !== void 0 && newLine !== void 0 ? diffHighlight(oldLine.content, newLine.content, isCombined, this.config) : void 0;
      const preparedOldLine = oldLine !== void 0 && oldLine.oldNumber !== void 0 ? Object.assign(Object.assign({}, diff2 !== void 0 ? {
        prefix: diff2.oldLine.prefix,
        content: diff2.oldLine.content,
        type: CSSLineClass.DELETE_CHANGES
      } : Object.assign(Object.assign({}, deconstructLine(oldLine.content, isCombined)), { type: toCSSClass(oldLine.type) })), { number: oldLine.oldNumber }) : void 0;
      const preparedNewLine = newLine !== void 0 && newLine.newNumber !== void 0 ? Object.assign(Object.assign({}, diff2 !== void 0 ? {
        prefix: diff2.newLine.prefix,
        content: diff2.newLine.content,
        type: CSSLineClass.INSERT_CHANGES
      } : Object.assign(Object.assign({}, deconstructLine(newLine.content, isCombined)), { type: toCSSClass(newLine.type) })), { number: newLine.newNumber }) : void 0;
      const { left, right } = this.generateLineHtml(preparedOldLine, preparedNewLine);
      fileHtml.left += left;
      fileHtml.right += right;
    }
    return fileHtml;
  }
  generateLineHtml(oldLine, newLine) {
    return {
      left: this.generateSingleHtml(oldLine),
      right: this.generateSingleHtml(newLine)
    };
  }
  generateSingleHtml(line) {
    const lineClass = "d2h-code-side-linenumber";
    const contentClass = "d2h-code-side-line";
    return this.hoganUtils.render(genericTemplatesPath2, "line", {
      type: (line === null || line === void 0 ? void 0 : line.type) || `${CSSLineClass.CONTEXT} d2h-emptyplaceholder`,
      lineClass: line !== void 0 ? lineClass : `${lineClass} d2h-code-side-emptyplaceholder`,
      contentClass: line !== void 0 ? contentClass : `${contentClass} d2h-code-side-emptyplaceholder`,
      prefix: (line === null || line === void 0 ? void 0 : line.prefix) === " " ? "&nbsp;" : line === null || line === void 0 ? void 0 : line.prefix,
      content: line === null || line === void 0 ? void 0 : line.content,
      lineNumber: line === null || line === void 0 ? void 0 : line.number
    });
  }
};

// node_modules/diff2html/lib-esm/hoganjs-utils.js
var Hogan3 = __toESM(require_hogan());

// node_modules/diff2html/lib-esm/diff2html-templates.js
var Hogan2 = __toESM(require_hogan());
var defaultTemplates = {};
defaultTemplates["file-summary-line"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<li class="d2h-file-list-line">');
  t.b("\n" + i);
  t.b('    <span class="d2h-file-name-wrapper">');
  t.b("\n" + i);
  t.b(t.rp("<fileIcon0", c, p, "      "));
  t.b('      <a href="#');
  t.b(t.v(t.f("fileHtmlId", c, p, 0)));
  t.b('" class="d2h-file-name">');
  t.b(t.v(t.f("fileName", c, p, 0)));
  t.b("</a>");
  t.b("\n" + i);
  t.b('      <span class="d2h-file-stats">');
  t.b("\n" + i);
  t.b('          <span class="d2h-lines-added">');
  t.b(t.v(t.f("addedLines", c, p, 0)));
  t.b("</span>");
  t.b("\n" + i);
  t.b('          <span class="d2h-lines-deleted">');
  t.b(t.v(t.f("deletedLines", c, p, 0)));
  t.b("</span>");
  t.b("\n" + i);
  t.b("      </span>");
  t.b("\n" + i);
  t.b("    </span>");
  t.b("\n" + i);
  t.b("</li>");
  return t.fl();
}, partials: { "<fileIcon0": { name: "fileIcon", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["file-summary-wrapper"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div class="d2h-file-list-wrapper ');
  t.b(t.v(t.f("colorScheme", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  t.b('    <div class="d2h-file-list-header">');
  t.b("\n" + i);
  t.b('        <span class="d2h-file-list-title">Files changed (');
  t.b(t.v(t.f("filesNumber", c, p, 0)));
  t.b(")</span>");
  t.b("\n" + i);
  t.b('        <a class="d2h-file-switch d2h-hide">hide</a>');
  t.b("\n" + i);
  t.b('        <a class="d2h-file-switch d2h-show">show</a>');
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b('    <ol class="d2h-file-list">');
  t.b("\n" + i);
  t.b("    ");
  t.b(t.t(t.f("files", c, p, 0)));
  t.b("\n" + i);
  t.b("    </ol>");
  t.b("\n" + i);
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-block-header"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b("<tr>");
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.f("lineClass", c, p, 0)));
  t.b(" ");
  t.b(t.v(t.d("CSSLineClass.INFO", c, p, 0)));
  t.b('"></td>');
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.d("CSSLineClass.INFO", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  t.b('        <div class="');
  t.b(t.v(t.f("contentClass", c, p, 0)));
  t.b('">');
  if (t.s(t.f("blockHeader", c, p, 1), c, p, 0, 156, 173, "{{ }}")) {
    t.rs(c, p, function(c2, p2, t2) {
      t2.b(t2.t(t2.f("blockHeader", c2, p2, 0)));
    });
    c.pop();
  }
  if (!t.s(t.f("blockHeader", c, p, 1), c, p, 1, 0, 0, "")) {
    t.b("&nbsp;");
  }
  ;
  t.b("</div>");
  t.b("\n" + i);
  t.b("    </td>");
  t.b("\n" + i);
  t.b("</tr>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-empty-diff"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b("<tr>");
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.d("CSSLineClass.INFO", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  t.b('        <div class="');
  t.b(t.v(t.f("contentClass", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  t.b("            File without changes");
  t.b("\n" + i);
  t.b("        </div>");
  t.b("\n" + i);
  t.b("    </td>");
  t.b("\n" + i);
  t.b("</tr>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-file-path"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="d2h-file-name-wrapper">');
  t.b("\n" + i);
  t.b(t.rp("<fileIcon0", c, p, "    "));
  t.b('    <span class="d2h-file-name">');
  t.b(t.v(t.f("fileDiffName", c, p, 0)));
  t.b("</span>");
  t.b("\n" + i);
  t.b(t.rp("<fileTag1", c, p, "    "));
  t.b("</span>");
  t.b("\n" + i);
  t.b('<label class="d2h-file-collapse">');
  t.b("\n" + i);
  t.b('    <input class="d2h-file-collapse-input" type="checkbox" name="viewed" value="viewed">');
  t.b("\n" + i);
  t.b("    Viewed");
  t.b("\n" + i);
  t.b("</label>");
  return t.fl();
}, partials: { "<fileIcon0": { name: "fileIcon", partials: {}, subs: {} }, "<fileTag1": { name: "fileTag", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["generic-line"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b("<tr>");
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.f("lineClass", c, p, 0)));
  t.b(" ");
  t.b(t.v(t.f("type", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  t.b("      ");
  t.b(t.t(t.f("lineNumber", c, p, 0)));
  t.b("\n" + i);
  t.b("    </td>");
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.f("type", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  t.b('        <div class="');
  t.b(t.v(t.f("contentClass", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  if (t.s(t.f("prefix", c, p, 1), c, p, 0, 162, 238, "{{ }}")) {
    t.rs(c, p, function(c2, p2, t2) {
      t2.b('            <span class="d2h-code-line-prefix">');
      t2.b(t2.t(t2.f("prefix", c2, p2, 0)));
      t2.b("</span>");
      t2.b("\n" + i);
    });
    c.pop();
  }
  if (!t.s(t.f("prefix", c, p, 1), c, p, 1, 0, 0, "")) {
    t.b('            <span class="d2h-code-line-prefix">&nbsp;</span>');
    t.b("\n" + i);
  }
  ;
  if (t.s(t.f("content", c, p, 1), c, p, 0, 371, 445, "{{ }}")) {
    t.rs(c, p, function(c2, p2, t2) {
      t2.b('            <span class="d2h-code-line-ctn">');
      t2.b(t2.t(t2.f("content", c2, p2, 0)));
      t2.b("</span>");
      t2.b("\n" + i);
    });
    c.pop();
  }
  if (!t.s(t.f("content", c, p, 1), c, p, 1, 0, 0, "")) {
    t.b('            <span class="d2h-code-line-ctn"><br></span>');
    t.b("\n" + i);
  }
  ;
  t.b("        </div>");
  t.b("\n" + i);
  t.b("    </td>");
  t.b("\n" + i);
  t.b("</tr>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-wrapper"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div class="d2h-wrapper ');
  t.b(t.v(t.f("colorScheme", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  t.b("    ");
  t.b(t.t(t.f("content", c, p, 0)));
  t.b("\n" + i);
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-added"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="d2h-icon d2h-added" height="16" title="added" version="1.1" viewBox="0 0 14 16"');
  t.b("\n" + i);
  t.b('     width="14">');
  t.b("\n" + i);
  t.b('    <path d="M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM6 9H3V7h3V4h2v3h3v2H8v3H6V9z"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-changed"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="d2h-icon d2h-changed" height="16" title="modified" version="1.1"');
  t.b("\n" + i);
  t.b('     viewBox="0 0 14 16" width="14">');
  t.b("\n" + i);
  t.b('    <path d="M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM4 8c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3-3-1.34-3-3z"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-deleted"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="d2h-icon d2h-deleted" height="16" title="removed" version="1.1"');
  t.b("\n" + i);
  t.b('     viewBox="0 0 14 16" width="14">');
  t.b("\n" + i);
  t.b('    <path d="M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM11 9H3V7h8v2z"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-renamed"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="d2h-icon d2h-moved" height="16" title="renamed" version="1.1"');
  t.b("\n" + i);
  t.b('     viewBox="0 0 14 16" width="14">');
  t.b("\n" + i);
  t.b('    <path d="M6 9H3V7h3V4l5 4-5 4V9z m8-7v12c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h12c0.55 0 1 0.45 1 1z m-1 0H1v12h12V2z"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="d2h-icon" height="16" version="1.1" viewBox="0 0 12 16" width="12">');
  t.b("\n" + i);
  t.b('    <path d="M6 5H2v-1h4v1zM2 8h7v-1H2v1z m0 2h7v-1H2v1z m0 2h7v-1H2v1z m10-7.5v9.5c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h7.5l3.5 3.5z m-1 0.5L8 2H1v12h10V5z"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["line-by-line-file-diff"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div id="');
  t.b(t.v(t.f("fileHtmlId", c, p, 0)));
  t.b('" class="d2h-file-wrapper" data-lang="');
  t.b(t.v(t.d("file.language", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  t.b('    <div class="d2h-file-header">');
  t.b("\n" + i);
  t.b("    ");
  t.b(t.t(t.f("filePath", c, p, 0)));
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b('    <div class="d2h-file-diff">');
  t.b("\n" + i);
  t.b('        <div class="d2h-code-wrapper">');
  t.b("\n" + i);
  t.b('            <table class="d2h-diff-table">');
  t.b("\n" + i);
  t.b('                <tbody class="d2h-diff-tbody">');
  t.b("\n" + i);
  t.b("                ");
  t.b(t.t(t.f("diffs", c, p, 0)));
  t.b("\n" + i);
  t.b("                </tbody>");
  t.b("\n" + i);
  t.b("            </table>");
  t.b("\n" + i);
  t.b("        </div>");
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["line-by-line-numbers"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div class="line-num1">');
  t.b(t.v(t.f("oldNumber", c, p, 0)));
  t.b("</div>");
  t.b("\n" + i);
  t.b('<div class="line-num2">');
  t.b(t.v(t.f("newNumber", c, p, 0)));
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["side-by-side-file-diff"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div id="');
  t.b(t.v(t.f("fileHtmlId", c, p, 0)));
  t.b('" class="d2h-file-wrapper" data-lang="');
  t.b(t.v(t.d("file.language", c, p, 0)));
  t.b('">');
  t.b("\n" + i);
  t.b('    <div class="d2h-file-header">');
  t.b("\n" + i);
  t.b("      ");
  t.b(t.t(t.f("filePath", c, p, 0)));
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b('    <div class="d2h-files-diff">');
  t.b("\n" + i);
  t.b('        <div class="d2h-file-side-diff">');
  t.b("\n" + i);
  t.b('            <div class="d2h-code-wrapper">');
  t.b("\n" + i);
  t.b('                <table class="d2h-diff-table">');
  t.b("\n" + i);
  t.b('                    <tbody class="d2h-diff-tbody">');
  t.b("\n" + i);
  t.b("                    ");
  t.b(t.t(t.d("diffs.left", c, p, 0)));
  t.b("\n" + i);
  t.b("                    </tbody>");
  t.b("\n" + i);
  t.b("                </table>");
  t.b("\n" + i);
  t.b("            </div>");
  t.b("\n" + i);
  t.b("        </div>");
  t.b("\n" + i);
  t.b('        <div class="d2h-file-side-diff">');
  t.b("\n" + i);
  t.b('            <div class="d2h-code-wrapper">');
  t.b("\n" + i);
  t.b('                <table class="d2h-diff-table">');
  t.b("\n" + i);
  t.b('                    <tbody class="d2h-diff-tbody">');
  t.b("\n" + i);
  t.b("                    ");
  t.b(t.t(t.d("diffs.right", c, p, 0)));
  t.b("\n" + i);
  t.b("                    </tbody>");
  t.b("\n" + i);
  t.b("                </table>");
  t.b("\n" + i);
  t.b("            </div>");
  t.b("\n" + i);
  t.b("        </div>");
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-added"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="d2h-tag d2h-added d2h-added-tag">ADDED</span>');
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-changed"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="d2h-tag d2h-changed d2h-changed-tag">CHANGED</span>');
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-deleted"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="d2h-tag d2h-deleted d2h-deleted-tag">DELETED</span>');
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-renamed"] = new Hogan2.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="d2h-tag d2h-moved d2h-moved-tag">RENAMED</span>');
  return t.fl();
}, partials: {}, subs: {} });

// node_modules/diff2html/lib-esm/hoganjs-utils.js
var HoganJsUtils = class {
  constructor({ compiledTemplates = {}, rawTemplates = {} }) {
    const compiledRawTemplates = Object.entries(rawTemplates).reduce((previousTemplates, [name, templateString]) => {
      const compiledTemplate = Hogan3.compile(templateString, { asString: false });
      return Object.assign(Object.assign({}, previousTemplates), { [name]: compiledTemplate });
    }, {});
    this.preCompiledTemplates = Object.assign(Object.assign(Object.assign({}, defaultTemplates), compiledTemplates), compiledRawTemplates);
  }
  static compile(templateString) {
    return Hogan3.compile(templateString, { asString: false });
  }
  render(namespace, view, params, partials, indent) {
    const templateKey = this.templateKey(namespace, view);
    try {
      const template = this.preCompiledTemplates[templateKey];
      return template.render(params, partials, indent);
    } catch (_e) {
      throw new Error(`Could not find template to render '${templateKey}'`);
    }
  }
  template(namespace, view) {
    return this.preCompiledTemplates[this.templateKey(namespace, view)];
  }
  templateKey(namespace, view) {
    return `${namespace}-${view}`;
  }
};

// node_modules/diff2html/lib-esm/diff2html.js
var defaultDiff2HtmlConfig = Object.assign(Object.assign(Object.assign({}, defaultLineByLineRendererConfig), defaultSideBySideRendererConfig), { outputFormat: OutputFormatType.LINE_BY_LINE, drawFileList: true });
function html(diffInput, configuration = {}) {
  const config = Object.assign(Object.assign({}, defaultDiff2HtmlConfig), configuration);
  const diffJson = typeof diffInput === "string" ? parse(diffInput, config) : diffInput;
  const hoganUtils = new HoganJsUtils(config);
  const { colorScheme } = config;
  const fileListRendererConfig = { colorScheme };
  const fileList = config.drawFileList ? new FileListRenderer(hoganUtils, fileListRendererConfig).render(diffJson) : "";
  const diffOutput = config.outputFormat === "side-by-side" ? new SideBySideRenderer(hoganUtils, config).render(diffJson) : new LineByLineRenderer(hoganUtils, config).render(diffJson);
  return fileList + diffOutput;
}

// src/modals/history.modal.ts
var import_obsidian7 = require("obsidian");
var HistoryModal = class extends import_obsidian7.Modal {
  /**
   * Creates a new instance of HistoryModal.
   *
   * @param {App} app - The Obsidian app instance
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   * @param {FileSnapshot} snapshot - The file snapshot to display history for
   */
  constructor(app, plugin, snapshot) {
    super(app);
    this.app = app;
    this.plugin = plugin;
    this.snapshot = snapshot;
    /**
     * The current display mode for the diff view.
     * Can be 'patch', 'line-by-line', or 'side-by-side'.
     * Defaults to 'side-by-side'.
     */
    this.currentDisplayMode = "side-by-side";
    /**
     * References to the mode toggle buttons.
     * Used to update the active state when switching between diff modes.
     */
    this.modeButtons = {};
    this.diffContainerEl = this.contentEl.createDiv("diff-container");
  }
  /**
   * Lifecycle method called when the modal is opened.
   * Sets up the UI, adds CSS classes, sets the title based on the snapshot state,
   * and renders the diff view.
   * Does nothing if no snapshot is provided.
   *
   * @override
   */
  onOpen() {
    if (!this.snapshot) {
      return;
    }
    this.makeUI();
    DomHelper.update(
      this.modalEl,
      { classes: { add: "lct-diff-modal" } }
    );
    this.renderDiff();
  }
  /**
   * Lifecycle method called when the modal is closed.
   * Cleans up by emptying the content element and removing scroll sync listeners.
   *
   * @override
   */
  onClose() {
    this.cleanupScrollSync();
    this.contentEl.empty();
  }
  /**
   * Gets the currently active button based on the current display mode.
   * Returns the button element that corresponds to the active diff view mode.
   *
   * @return {HTMLElement | null} The active button element, or null if no mode is active
   */
  getActiveButton() {
    switch (this.currentDisplayMode) {
      case "patch":
        return this.modeButtons.patch;
      case "line-by-line":
        return this.modeButtons.lineByLine;
      case "side-by-side":
        return this.modeButtons.sideBySide;
      default:
        return null;
    }
  }
  /**
   * Updates the active state of mode buttons based on the current display mode.
   */
  updateButtonActiveStates() {
    Object.values(this.modeButtons).forEach((button) => {
      DomHelper.update(
        button,
        { classes: { remove: "mod-cta" } }
      );
    });
    const activeButton = this.getActiveButton();
    if (!activeButton) {
      return;
    }
    DomHelper.update(
      activeButton,
      { classes: { add: "mod-cta" } }
    );
  }
  /**
   * Restores the file to its original state and resets the history tracking.
   * Writes the original content back to the file and clears the snapshot.
   */
  async restoreOriginalFile() {
    if (!this.snapshot) {
      return;
    }
    try {
      const originalContent = this.snapshot.getOriginalState();
      const file = this.snapshot.file;
      await this.app.vault.modify(file, originalContent);
      this.snapshotsService.wipeOne(file);
      new import_obsidian7.Notice("File restored to original state");
      this.close();
    } catch (_error) {
      new import_obsidian7.Notice("Failed to restore file to original state");
    }
  }
  /**
   * Creates the UI elements for the diff view.
   */
  makeUI() {
    var _a, _b;
    const isOrigin = (_a = this.snapshot) == null ? void 0 : _a.isStateSameOriginal();
    const changeDateTime = (_b = this.snapshot) == null ? void 0 : _b.getLastChangedDateTime();
    this.setTitle("History");
    new import_obsidian7.Setting(this.contentEl).setName("Last modified").setDesc(isOrigin ? "No changes" : changeDateTime).addButton((btn) => btn.setButtonText("Remove file history").setWarning().onClick(async () => {
      var _a2;
      const confirmed = await this.modalsService.confirm({
        title: "Remove File History",
        // eslint-disable-next-line max-len
        message: "Are you sure you want to remove the change tracking history for this file? This action cannot be undone.",
        confirmText: "Remove History"
      });
      if (confirmed) {
        (_a2 = this.snapshotsService) == null ? void 0 : _a2.wipeOne(this.snapshot.file);
        this.close();
      }
    })).addButton((btn) => btn.setButtonText("Restore original").setWarning().onClick(async () => {
      const confirmed = await this.modalsService.confirm({
        title: "Restore Original File",
        // eslint-disable-next-line max-len
        message: "Are you sure you want to restore this file to its original state? All current changes will be lost and the change tracking history will be reset. This action cannot be undone.",
        confirmText: "Restore File"
      });
      if (confirmed) {
        await this.restoreOriginalFile();
      }
    })).addButton((btn) => {
      this.modeButtons.patch = btn.buttonEl;
      return btn.setButtonText("Show patch").onClick(() => {
        this.showCleanPatch();
      });
    }).addButton((btn) => {
      this.modeButtons.lineByLine = btn.buttonEl;
      return btn.setButtonText("Line by line").onClick(() => {
        this.renderDiff("line-by-line" /* line */);
      });
    }).addButton((btn) => {
      this.modeButtons.sideBySide = btn.buttonEl;
      return btn.setButtonText("side-by-side").onClick(() => {
        this.renderDiff("side-by-side" /* side */);
      });
    });
    this.updateButtonActiveStates();
  }
  /**
   * Generates a unified diff between the original and current state of the file.
   * If the file has changes, use the diff library to create a patch.
   * If the file has no changes, create a simple diff header with the file content.
   *
   * @return {string} A string containing the unified diff
   */
  getDiffLines() {
    var _a, _b;
    if (!((_b = (_a = this.snapshot) == null ? void 0 : _a.file) == null ? void 0 : _b.path)) {
      return "";
    }
    const filePath = this.snapshot.file.path;
    const original = this.snapshot.getOriginalState();
    const current = this.snapshot.getLastState();
    if (!this.snapshot.isStateSameOriginal()) {
      return createTwoFilesPatch(
        filePath,
        filePath,
        original != null ? original : "",
        current != null ? current : "",
        "",
        "",
        {
          context: Number.MAX_SAFE_INTEGER
        }
      );
    }
    return [
      "===================================================================",
      `--- ${filePath}	`,
      `+++ ${filePath}	`,
      `@@ -1,${original.length} +1,${current.length} @@`,
      this.snapshot.getLastStateLines().map((content) => ` ${content}`).join("\n"),
      "\\ No newline at end of file"
    ].join("\n");
  }
  /**
   * Generates a clean patch with context size 0 between the original and current state of the file.
   * Shows only the changed lines without surrounding context.
   *
   * @return {string} A string containing the clean patch
   */
  getCleanPatch() {
    var _a, _b;
    if (!((_b = (_a = this.snapshot) == null ? void 0 : _a.file) == null ? void 0 : _b.path)) {
      return "";
    }
    const filePath = this.snapshot.file.path;
    const original = this.snapshot.getOriginalState();
    const current = this.snapshot.getLastState();
    if (!this.snapshot.isStateSameOriginal()) {
      return createTwoFilesPatch(
        filePath,
        filePath,
        original != null ? original : "",
        current != null ? current : "",
        "",
        "",
        {
          context: 0
        }
      );
    }
    return `--- ${filePath}	
+++ ${filePath}	
`;
  }
  /**
   * Shows the clean patch in a readable format.
   * Displays the patch with context size 0 in a pre-formatted text element.
   */
  showCleanPatch() {
    this.currentDisplayMode = "patch";
    this.updateButtonActiveStates();
    this.cleanupScrollSync();
    const patch = this.getCleanPatch();
    const handlerClick = () => {
      navigator.clipboard.writeText(patch).then(() => {
        new import_obsidian7.Notice("Copied!");
      });
    };
    DomHelper.update(
      this.diffContainerEl,
      {
        text: null,
        children: [
          {
            tag: "div",
            classes: "lct-patch-container",
            children: [
              {
                tag: "pre",
                classes: "lct-patch-text",
                text: patch
              },
              {
                tag: "button",
                text: "Copy",
                classes: ["lct-patch-copy-button", "mod-outline"],
                events: {
                  click: handlerClick
                }
              }
            ]
          }
        ]
      }
    );
  }
  /**
   * Renders the diff view in the specified container.
   * Converts the unified diff to HTML using the diff2html library.
   * Supports two formats: 'line-by-line' and 'side-by-side'.
   * Use custom templates to control the HTML structure and styling.
   *
   * @param {DiffOutputFormatType} format - The format of the diff view (defaults to 'side-by-side')
   */
  renderDiff(format = "side-by-side" /* side */) {
    this.currentDisplayMode = format;
    this.updateButtonActiveStates();
    this.cleanupScrollSync();
    const diffHtml = html(this.getDiffLines(), {
      drawFileList: false,
      matching: "lines",
      outputFormat: format,
      renderNothingWhenEmpty: true,
      rawTemplates: {
        "line-by-line-file-diff": `
           {{{diffs}}}
        `,
        "side-by-side-file-diff": `
          <div class="d2h-side-column">
            <div class="d2h-side-column-wrapper">
                <div class="d2h-side-column-container">
                  {{{diffs.left}}}
              </div>
            </div>
          </div>
          <div class="d2h-side-column">
            <div class="d2h-side-column-wrapper">
                <div class="d2h-side-column-container">
                  {{{diffs.right}}}
              </div>
            </div>
          </div>
        `,
        "generic-wrapper": `
          <div class="d2h-wrapper d2h-${format === "line-by-line" /* line */ ? "line" : "side"}">
            <div class="d2h-container">
                {{{content}}}
            </div>
          </div>
        `,
        "generic-block-header": `
          <div class="d2h-code-row-wrapper d2h-code-header-wrapper {{CSSLineClass.INFO}}">
              <div class="d2h-code-linenumber {{CSSLineClass.INFO}}"></div>
              <div class="d2h-code-linecontent {{CSSLineClass.INFO}}">
                  <div class="d2h-code-line d2h-code-row">
                    <span class="d2h-code-line-prefix">&nbsp;</span>
                    <span class="d2h-code-line-ctn">
                      {{#blockHeader}}{{{blockHeader}}}{{/blockHeader}}{{^blockHeader}}&nbsp;{{/blockHeader}}
                    </span>
                  </div>
              </div>
          </div>
        `,
        "generic-line": `
          <div class="d2h-code-row-wrapper {{type}}">
            <div class="d2h-code-linenumber {{type}}">
              {{{lineNumber}}}
            </div>
            <div class="d2h-code-linecontent {{type}}">
                <div class="d2h-code-line d2h-code-row">
                  {{#prefix}}
                      <span class="d2h-code-line-prefix">{{{prefix}}}</span>
                  {{/prefix}}
                  {{^prefix}}
                      <span class="d2h-code-line-prefix">&nbsp;</span>
                  {{/prefix}}
                  {{#content}}
                      <span class="d2h-code-line-ctn">{{{content}}}</span>
                  {{/content}}
                  {{^content}}
                      <span class="d2h-code-line-ctn"><br></span>
                  {{/content}}
                </div>
            </div>
        </div>
        `
      }
    });
    DomHelper.update(
      this.diffContainerEl,
      { html: diffHtml }
    );
    if (format === "side-by-side") {
      setTimeout(() => this.setupScrollSynchronization(), 0);
    }
  }
  /**
   * Sets up scroll synchronization for a side-by-side diff view.
   * Finds the scrollable wrapper elements for both columns and adds event listeners
   * to synchronize both vertical and horizontal scroll positions.
   */
  setupScrollSynchronization() {
    const wrappers = this.diffContainerEl.querySelectorAll(".d2h-side-column-wrapper");
    if ((wrappers == null ? void 0 : wrappers.length) !== 2) {
      return;
    }
    const [leftWrapper, rightWrapper] = wrappers;
    let isScrolling = false;
    const syncLeftToRight = () => {
      if (isScrolling) {
        return;
      }
      isScrolling = true;
      rightWrapper.scrollTop = leftWrapper.scrollTop;
      rightWrapper.scrollLeft = leftWrapper.scrollLeft;
      requestAnimationFrame(() => {
        isScrolling = false;
      });
    };
    const syncRightToLeft = () => {
      if (isScrolling) {
        return;
      }
      isScrolling = true;
      leftWrapper.scrollTop = rightWrapper.scrollTop;
      leftWrapper.scrollLeft = rightWrapper.scrollLeft;
      requestAnimationFrame(() => {
        isScrolling = false;
      });
    };
    leftWrapper.addEventListener("scroll", syncLeftToRight);
    rightWrapper.addEventListener("scroll", syncRightToLeft);
    this.diffContainerEl._scrollSyncCleanup = () => {
      leftWrapper.removeEventListener("scroll", syncLeftToRight);
      rightWrapper.removeEventListener("scroll", syncRightToLeft);
    };
  }
  /**
   * Cleans up scroll synchronization event listeners.
   * Called when switching between diff modes or closing the modal.
   */
  cleanupScrollSync() {
    const container = this.diffContainerEl;
    if (container == null ? void 0 : container._scrollSyncCleanup) {
      container._scrollSyncCleanup();
      delete container._scrollSyncCleanup;
    }
  }
};
__decorateClass([
  Inject("SnapshotsService")
], HistoryModal.prototype, "snapshotsService", 2);
__decorateClass([
  Inject("ModalsService")
], HistoryModal.prototype, "modalsService", 2);

// src/services/modals.service.ts
var ModalsService = class {
  /**
   * Creates a new instance of ModalsService.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Initializes the service.
   * This method is called during plugin initialization.
   * Currently, it does not perform any initialization actions.
   */
  init() {
  }
  /**
   * Opens a diff/history modal for a file.
   * Retrieves the file snapshot and opens a HistoryModal if the snapshot exists.
   *
   * @param {TFile} file - The file to show diff for, or null to use the active file
   * @return {boolean} True if the modal was opened successfully, false if no snapshot exists
   */
  diff(file) {
    const snapshot = this.snapshotsService.getOne(file);
    if (!snapshot) {
      return false;
    }
    new HistoryModal(this.plugin.app, this.plugin, snapshot).open();
    return true;
  }
  /**
   * Shows a confirmation dialog with the specified configuration.
   * Creates a ConfirmModal instance and returns a promise that resolves with the user's choice.
   *
   * @param {ConfirmModalConfig} config - Configuration object for the confirmation dialog
   * @return {Promise<boolean>} Promise that resolves to true if confirmed, false if cancelled
   */
  async confirm(config) {
    const modal = new ConfirmModal(this.plugin.app, config);
    return await modal.confirm();
  }
};
__decorateClass([
  Inject("SnapshotsService")
], ModalsService.prototype, "snapshotsService", 2);

// src/settings/main.setting.ts
var import_obsidian8 = require("obsidian");
var MainSetting = class extends import_obsidian8.PluginSettingTab {
  /**
   * Renders the settings UI.
   * Creates and configures all settings elements in the settings tab.
   * Organizes settings into logical sections:
   * - Indicator type (line or dot in gutter)
   * - History retention options
   * - Toggle switches for different change types (changed, restored, added, removed)
   * - Line indicator width configuration
   * - Gutter indicator character customization
   *
   * Each setting is bound to the corresponding value in the plugin settings
   * and updates the settings when changed.
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian8.Setting(containerEl).setName("Type").setDesc("Choose between a vertical line or a dot in the gutter.").addDropdown(
      (dropdown) => dropdown.addOption("line" /* line */, "Vertical Line").addOption("dot" /* dot */, "Char in Gutter").setValue(this.settingsService.value("type")).onChange((value) => {
        this.settingsService.update("type", value);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Allowed file extensions").setDesc("Comma-separated list of file extensions to track for changes (e.g., md, txt, csv, json, yaml)").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.allowedExtensions).setValue(this.settingsService.value("allowedExtensions")).onChange((value) => {
        this.settingsService.update(
          "allowedExtensions",
          value || DEFAULT_SETTINGS.allowedExtensions
        );
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Keep history until").setDesc("Strategy for cleaning up revision history").addDropdown(
      (dropdown) => dropdown.addOption("app" /* app */, "App close").addOption("file" /* file */, "File close").setValue(this.settingsService.value("keep")).onChange((value) => {
        this.settingsService.update("keep", value);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Ignore new files").setDesc("Don't track changes in files created after tracking started").addToggle(
      (toggle) => toggle.setValue(this.settingsService.value("ignoreNewFiles")).onChange((value) => {
        this.settingsService.update("ignoreNewFiles", value);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Show indicator for").setHeading();
    new import_obsidian8.Setting(containerEl).setName("Changed").addToggle(
      (toggle) => toggle.setValue(this.settingsService.value("show.changed")).onChange((value) => {
        this.settingsService.update("show.changed", value);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Restored").addToggle(
      (toggle) => toggle.setValue(this.settingsService.value("show.restored")).onChange((value) => {
        this.settingsService.update("show.restored", value);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Added").addToggle(
      (toggle) => toggle.setValue(this.settingsService.value("show.added")).onChange((value) => {
        this.settingsService.update("show.added", value);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Removed").addToggle(
      (toggle) => toggle.setValue(this.settingsService.value("show.removed")).onChange((value) => {
        this.settingsService.update("show.removed", value);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Line indicator").setHeading();
    new import_obsidian8.Setting(containerEl).setName("Width").setDesc("Width of the vertical line indicator (in pixels).").addSlider(
      (slider) => slider.setLimits(1, 5, 1).setValue(this.settingsService.value("line.width")).setDynamicTooltip().onChange((value) => {
        this.settingsService.update("line.width", value);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Gutter indicator").setDesc((() => {
      return DomHelper.createFragment([
        {
          tag: "div",
          children: [
            {
              tag: "span",
              text: "Chars of the gutter type indicator ("
            },
            {
              tag: "a",
              text: "https://symbl.cc/en/unicode-table/",
              attributes: {
                href: "https://symbl.cc/en/unicode-table/",
                target: "_blank"
              }
            },
            {
              tag: "span",
              text: ")."
            }
          ]
        }
      ]);
    })()).setHeading();
    new import_obsidian8.Setting(containerEl).setName("Change char").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.gutter.changed).setValue(this.settingsService.value("gutter.changed")).onChange((value) => {
        this.settingsService.update("gutter.changed", value || DEFAULT_SETTINGS.gutter.changed);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Added char").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.gutter.added).setValue(this.settingsService.value("gutter.added")).onChange((value) => {
        this.settingsService.update("gutter.added", value || DEFAULT_SETTINGS.gutter.added);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Restore char").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.gutter.restored).setValue(this.settingsService.value("gutter.restored")).onChange((value) => {
        this.settingsService.update("gutter.restored", value || DEFAULT_SETTINGS.gutter.restored);
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Removed char").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.gutter.removed).setValue(this.settingsService.value("gutter.removed")).onChange((value) => {
        this.settingsService.update("gutter.removed", value || DEFAULT_SETTINGS.gutter.removed);
      })
    );
  }
};
__decorateClass([
  Inject("SettingsService")
], MainSetting.prototype, "settingsService", 2);

// src/services/settings.service.ts
var SettingsService = class {
  /**
   * Creates a new instance of SettingsService.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * The plugin settings data.
     * Initialized with default settings and updated from saved data during initialization.
     */
    this.data = DEFAULT_SETTINGS;
  }
  /**
   * Initializes the service.
   * Loads saved settings data and added the settings tab to the plugin.
   */
  async init() {
    this.data = Object.assign({}, DEFAULT_SETTINGS, await this.plugin.loadData());
    this.plugin.addSettingTab(new MainSetting(this.plugin.app, this.plugin));
  }
  /**
   * Gets a copy of all settings values.
   *
   * @return {LineChangeTrackerSettings} A copy of the settings data
   */
  values() {
    return { ...this.data };
  }
  /**
   * Updates a specific setting value.
   * Saves the updated settings to disk, forces an editor update,
   * and emits a settings update event.
   *
   * @template Path - The path to the setting
   * @template Value - The type of the setting value
   * @param {Path} path - The path to the setting to update
   * @param {Value} value - The new value for the setting
   */
  update(path, value) {
    set_default(this.data, path, value);
    void this.plugin.saveData(this.data);
    this.plugin.forceUpdateEditor();
    this.plugin.emit("settings:update" /* settingsUpdate */, { key: path, value });
  }
  /**
   * Gets a value from the settings by path.
   * Supports accessing nested properties using dot notation.
   *
   * @template Path - The path to the setting
   * @param {Path} path - The path to the setting to retrieve
   * @return {*} The value at the specified path
   */
  value(path) {
    return get_default(this.data, path);
  }
};

// src/maps/observable.map.ts
var ObservableMap = class extends Map {
  constructor() {
    super(...arguments);
    /**
     * Set of change handler functions that are notified when the map changes.
     * Each handler is called with the action type and relevant key/value.
     */
    this.listeners = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribes a handler function to be called when the map changes.
   * Returns an object with an unsubscribe method to remove the handler.
   *
   * @param {Function} handler - The function to call when the map changes
   * @return {Object} An object with an unsubscribe method
   */
  subscribe(handler) {
    this.listeners.add(handler);
    const listeners = this.listeners;
    return {
      unsubscribe() {
        listeners.delete(handler);
      }
    };
  }
  /**
   * Unsubscribes a handler function from map change notifications.
   *
   * @param {Function} handler - The handler function to remove
   */
  unsubscribe(handler) {
    this.listeners.delete(handler);
  }
  /**
   * Notifies all subscribed handlers of a change to the map.
   * Called internally by the set, delete, and clear methods.
   *
   * @param {string} action - The type of change that occurred
   * @param {*} key - The key that was affected (if applicable)
   * @param {*} value - The value that was affected (if applicable)
   */
  next(action, key2, value) {
    for (const listener of this.listeners) {
      listener(action, key2, value);
    }
  }
  /**
   * Sets a key-value pair in the map and notifies listeners of the change.
   * Only notifies listeners if the value has changed or if force is true.
   *
   * @param {*} key - The key to set
   * @param {*} value - The value to set
   * @param {boolean} force - Whether to force notification even if the value hasn't changed
   * @return {this} This map instance for method chaining
   * @override
   */
  set(key2, value, force) {
    const hadKey = this.has(key2);
    const prev = this.get(key2);
    super.set(key2, value);
    if (force || !hadKey || prev !== value) {
      this.next("set", key2, value);
    }
    return this;
  }
  /**
   * Deletes a key-value pair from the map and notifies listeners of the change.
   * Only notifies listeners if a key was actually deleted or if force is true.
   *
   * @param {*} key - The key to delete
   * @param {boolean} force - Whether to force notification even if no key was deleted
   * @return {boolean} True if the key was deleted, false otherwise
   * @override
   */
  delete(key2, force) {
    const result = super.delete(key2);
    if (force || result) {
      this.next("delete", key2);
    }
    return result;
  }
  /**
   * Clears all key-value pairs from the map and notifies listeners of the change.
   * Only notifies listeners if the map wasn't empty or if force is true.
   *
   * @param {boolean} force - Whether to force notification even if the map was empty
   * @return {number} The number of key-value pairs that were in the map before clearing
   * @override
   */
  clear(force) {
    const size = this.size;
    super.clear();
    if (force || size > 0) {
      this.next("clear");
    }
    return size;
  }
};

// src/helpers/text.helper.ts
var TextHelper = class {
  /**
   * Generates a hash from a string content.
   * Uses a simple algorithm to convert the string to a numeric hash.
   *
   * @param {string} content - The string to hash
   * @return {string} The hash as a string (absolute value)
   */
  static hash(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      hash = (hash << 5) - hash + content.charCodeAt(i);
      hash |= 0;
    }
    return Math.abs(hash).toString();
  }
  /**
   * Generates a random alphanumeric identifier.
   * Converts a random number to base 36 (alphanumeric) and optionally adds a prefix.
   *
   * @param {string} prefix - Optional prefix to add to the beginning of the ID
   * @return {string} A random alphanumeric string that can be used as an identifier
   */
  static rndId(prefix) {
    return Math.random().toString(36).replace("0.", prefix || "");
  }
};

// src/lines/change.line.ts
var ChangeLine = class {
  /**
   * Creates a new instance of ChangeLine.
   *
   * @param {number} line - The line number this change applies to
   * @param {ChangeType[]} types - Array of change types applied to this line
   */
  constructor(line, types) {
    this.line = line;
    this.types = types;
  }
  /**
   * Adds a change type to this line if it doesn't already have that type.
   * Prevents duplicate change types for the same line.
   *
   * @param {ChangeType} type - The change type to add
   * @return {void}
   */
  add(type) {
    if (!this.has(type)) {
      this.types.push(type);
    }
  }
  /**
   * Checks if this line has a specific change type or any of the types in an array.
   *
   * @param {ChangeType | ChangeType[]} type - A single change type or array of change types to check for
   * @return {boolean} True if the line has any of the specified change types, false otherwise
   */
  has(type) {
    const list = isArray_default(type) ? type : [type];
    return this.types.some((item) => list.includes(item));
  }
  /**
   * Gets all change types applied to this line.
   * Returns a copy of the internal array to prevent direct modification.
   *
   * @return {ChangeType[]} Array of change types applied to this line
   */
  getTypes() {
    return [...this.types];
  }
  /**
   * Gets the first non-removed change type for this line.
   * Used to determine the primary modification type for display purposes.
   *
   * @return {ChangeType | null} The first change type that is not 'removed', or null if none exists
   */
  getModify() {
    var _a;
    return (_a = this.types.find((type) => type !== "removed" /* removed */)) != null ? _a : null;
  }
  /**
   * Gets the line number this change applies to.
   *
   * @return {number} The line number
   */
  getLine() {
    return this.line;
  }
};

// src/lines/tracker.line.ts
var TrackerLine = class {
  /**
   * Creates a new instance of TrackerLine.
   * Initializes the line tracker with optional parameters for content and position.
   *
   * @param {TrackerLineParams} params - Optional parameters to initialize the tracker line
   */
  constructor(params) {
    /** Unique identifier for this tracker line */
    this.id = TextHelper.rndId();
    /**
     * The original position (line number) in the document
     * Value of -1 indicates the line didn't exist in the original document
     */
    this.originalPosition = -1;
    /**
     * The current position (line number) in the document
     * Value of -1 indicates the line has been removed
     */
    this.currentPosition = -1;
    /**
     * The position where the line was removed
     * Shifts when the number of lines in the document changes
     * Value of -1 indicates the line hasn't been removed
     */
    this.removedAtPosition = -1;
    /**
     * The position where the line was last changed
     * Does NOT shift when the number of lines in the document changes
     * Value of -1 indicates the line hasn't been changed
     */
    this.changeAtPosition = -1;
    /**
     * Whether the current content is the same as in the original document
     * Used to determine if a line has been restored to its original state
     */
    this.contentSameOriginal = false;
    /**
     * Hash of the line content
     * Used for efficient content comparison
     */
    this.hash = null;
    /**
     * Original content of the line (for development use only)
     */
    this.original = null;
    /**
     * Current content of the line (for development use only)
     */
    this.current = null;
    /**
     * Timestamp when the line was removed
     * Used for sorting and tracking removal order
     * Value of -1 indicates the line hasn't been removed
     */
    this.removedTimeStamp = -1;
    /**
     * Timestamp when the line was last changed
     * Used for sorting and tracking change order
     * Value of -1 indicates the line hasn't been changed
     */
    this.changedTimeStamp = -1;
    // todo: remove or use it
    /**
     * Timestamp when the line was added
     * Used for sorting and tracking addition order
     */
    this.addedTimeStamp = Date.now();
    const {
      content,
      originalPosition,
      currentPosition,
      contentSameOriginal
    } = params != null ? params : {};
    if (isNumber_default(originalPosition)) {
      this.originalPosition = originalPosition;
    }
    if (isNumber_default(currentPosition)) {
      this.currentPosition = currentPosition;
    }
    if (isString_default(content)) {
      this.current = content;
      this.hash = TextHelper.hash(content);
    }
    if (contentSameOriginal === true) {
      this.original = content;
      this.contentSameOriginal = this.existedInOriginal && this.contentHashed;
    }
  }
  /**
   * Gets a unique key for this tracker line.
   * Combines position information with a prefix indicating if the line exists in the current document,
   * and the line's unique ID.
   *
   * @return {string} A string key that uniquely identifies this line
   */
  get key() {
    const prefix = this.existedInCurrent ? "crn" : "org";
    const position = String(
      Math.max(this.originalPosition, this.currentPosition)
    ).padStart(4, "0");
    return `${position}-${prefix}-${this.id}`;
  }
  /**
   * Checks if the line has been explicitly removed.
   * Does not consider whether the line existed in the original document.
   *
   * @return {boolean} True if the line has been removed, false otherwise
   */
  get wasExplicitlyRemoved() {
    return this.removedAtPosition !== -1;
  }
  /**
   * Checks if the line has been explicitly changed.
   * Does not consider whether the line existed in the original document.
   *
   * @return {boolean} True if the line has been changed, false otherwise
   */
  get wasExplicitlyChanged() {
    return this.changeAtPosition !== -1;
  }
  /**
   * Checks if the line existed in the original document.
   *
   * @return {boolean} True if the line existed in the original document, false otherwise
   */
  get existedInOriginal() {
    return this.originalPosition !== -1;
  }
  /**
   * Checks if the line exists in the current document.
   *
   * @return {boolean} True if the line exists in the current document, false otherwise
   */
  get existedInCurrent() {
    return this.currentPosition !== -1;
  }
  /**
   * Checks if the line has a content hash.
   * Used to determine if content comparison is possible.
   *
   * @return {boolean} True if the line has a content hash, false otherwise
   */
  get contentHashed() {
    return isString_default(this.hash) && !!this.hash;
  }
  /**
   * Checks if this tracker line is equal to another tracker line.
   * Lines are considered equal if they are the same instance or have the same ID.
   *
   * @param {TrackerLine} item - The tracker line to compare with
   * @return {boolean} True if the lines are equal, false otherwise
   */
  isEq(item) {
    return item === this || item.id === this.id;
  }
  /**
   * Checks if this line is a "ghost" line.
   * A ghost line is one that didn't exist in the original document and was later removed.
   *
   * @return {boolean} True if the line is a ghost line, false otherwise
   */
  isStateGhost() {
    return !this.existedInOriginal && !this.existedInCurrent && this.wasExplicitlyRemoved;
  }
  /**
   * Checks if this line has been removed.
   * A removed line existed in the original document but no longer exists in the current document.
   *
   * @return {boolean} True if the line has been removed, false otherwise
   */
  isStateRemoved() {
    return !this.existedInCurrent && this.existedInOriginal && this.wasExplicitlyRemoved;
  }
  /**
   * Checks if this line was removed at a specific position.
   *
   * @param {number} line - The line number to check
   * @return {boolean} True if the line was removed at the specified position, false otherwise
   */
  isStateRemovedAt(line) {
    return !this.existedInCurrent && this.existedInOriginal && this.removedAtPosition === line;
  }
  /**
   * Checks if this line has been added.
   * An added line didn't exist in the original document but exists in the current document.
   *
   * @return {boolean} True if the line has been added, false otherwise
   */
  isStateAdded() {
    return !this.existedInOriginal && !this.wasExplicitlyRemoved && this.existedInCurrent;
  }
  /**
   * Checks if this line has been changed.
   * A changed line existed in the original document, exists in the current document,
   * has different content from the original, and has not been removed.
   *
   * @return {boolean} True if the line has been changed, false otherwise
   */
  isStateChanged() {
    return this.existedInOriginal && this.existedInCurrent && !this.contentSameOriginal && !this.wasExplicitlyRemoved && this.wasExplicitlyChanged;
  }
  /**
   * Checks if this line is in its original state.
   * An original line existed in the original document, has the same content as the original,
   * and has not been removed.
   *
   * @return {boolean} True if the line is in its original state, false otherwise
   */
  isStateOriginal() {
    return this.existedInOriginal && this.contentSameOriginal && !this.wasExplicitlyRemoved;
  }
  /**
   * Checks if this line has been restored to its original state.
   * A restored line has the same content as the original, has not been removed,
   * but has been explicitly changed at some point.
   *
   * @return {boolean} True if the line has been restored, false otherwise
   */
  isStateRestored() {
    return this.contentSameOriginal && !this.wasExplicitlyRemoved && this.wasExplicitlyChanged;
  }
  /**
   * Checks if this line is currently at a specific position.
   *
   * @param {number} line - The line number to check
   * @return {boolean} True if the line is currently at the specified position, false otherwise
   */
  isCurrentAt(line) {
    return this.currentPosition === line;
  }
  /**
   * Checks if this line's current position is greater than a specific line number.
   *
   * @param {number} line - The line number to compare with
   * @return {boolean} True if the line's current position is greater than the specified line number, false otherwise
   */
  isCurrentGT(line) {
    return this.currentPosition > line;
  }
  /**
   * Checks if this line's current position is less than a specific line number.
   *
   * @param {number} line - The line number to compare with
   * @return {boolean} True if the line's current position is less than the specified line number, false otherwise
   */
  isCurrentLT(line) {
    return this.currentPosition < line;
  }
  /**
   * Gets the offset between a specified line number and this line's current position.
   * Used to determine how far to shift the line when moving it.
   *
   * @param {number} line - The line number to calculate the offset from
   * @return {number} The offset (positive or negative) between the specified line number and this line's
   *   current position
   */
  getCurrentPositionOffset(line) {
    return line - this.currentPosition;
  }
  /**
   * Checks if this line was originally at a specific position.
   *
   * @param {number} line - The line number to check
   * @return {boolean} True if the line was originally at the specified position, false otherwise
   */
  isOriginAt(line) {
    return this.originalPosition === line;
  }
  /**
   * Checks if this line's original position is within a specified range.
   * If no upper bound is provided, checks if the original position is greater than or equal to the lower bound.
   *
   * @param {number} from - The lower bound of the range (inclusive)
   * @param {number} to - The upper bound of the range (inclusive), optional
   * @return {boolean} True if the line's original position is within the specified range, false otherwise
   */
  isOriginalInRange(from, to) {
    return this.originalPosition >= from && (!to || this.originalPosition <= to);
  }
  /**
   * Checks if this line's current position is within a specified range.
   * If no upper bound is provided, checks if the current position is greater than or equal to the lower bound.
   *
   * @param {number} from - The lower bound of the range (inclusive)
   * @param {number} to - The upper bound of the range (inclusive), optional
   * @return {boolean} True if the line's current position is within the specified range, false otherwise
   */
  isCurrentInRange(from, to) {
    return this.currentPosition >= from && (!to || this.currentPosition <= to);
  }
  /**
   * Checks if this line's removed position is within a specified range.
   * If no upper bound is provided, checks if the removed position is greater than or equal to the lower bound.
   * Used to determine if a line was removed within a specific range of lines.
   *
   * @param {number} from - The lower bound of the range (inclusive)
   * @param {number} to - The upper bound of the range (inclusive), optional
   * @return {boolean} True if the line's removed position is within the specified range, false otherwise
   */
  isRemoveInRange(from, to) {
    return this.removedAtPosition >= from && (!to || this.removedAtPosition <= to);
  }
  /**
   * Moves this line to a new position in the document.
   * Updates the current position and change position, but only if the line exists in the current document.
   *
   * @param {number} line - The new line number to move to
   */
  moveTo(line) {
    if (!this.existedInCurrent) {
      return;
    }
    this.currentPosition = line;
    this.changeAtPosition = line;
  }
  /**
   * Restores a previously removed line.
   * Sets the current position to the specified line number or the original removed position,
   * and clears the removed flags.
   * Only works for lines that existed in the original document.
   *
   * @param {number} line - Optional new line number to restore to (defaults to the removed position)
   * @return {this} This tracker line instance for method chaining
   */
  restore(line) {
    if (!this.existedInOriginal) {
      return this;
    }
    this.currentPosition = line != null ? line : this.removedAtPosition;
    this.changeAtPosition = line != null ? line : this.removedAtPosition;
    this.removedAtPosition = -1;
    this.removedTimeStamp = -1;
    return this;
  }
  /**
   * Marks this line as removed.
   * Records the position where it was removed and sets the current position to -1.
   * Does nothing if the line is already marked as removed.
   *
   * @param {number} line - Optional line number where the removal occurred (defaults to current position)
   * @return {this} This tracker line instance for method chaining
   */
  remove(line) {
    if (this.wasExplicitlyRemoved) {
      return this;
    }
    this.removedAtPosition = line != null ? line : this.currentPosition;
    this.currentPosition = -1;
    this.removedTimeStamp = Date.now();
    return this;
  }
  /**
   * Changes the content of this line.
   * Updates the content hash, checks if the content matches the original,
   * and records the change position and timestamp.
   * Does nothing if the content is not a string or if the line doesn't exist in the current document.
   *
   * @param {string} content - The new content for the line
   * @param {number} line - Optional line number where the change occurred (defaults to current position)
   */
  change(content, line) {
    if (!isString_default(content) || !this.existedInCurrent) {
      return;
    }
    const hash = TextHelper.hash(content);
    if (hash === this.hash && this.contentSameOriginal) {
      return;
    }
    this.current = content;
    this.contentSameOriginal = this.hash === hash;
    this.changeAtPosition = line != null ? line : this.currentPosition;
    this.changedTimeStamp = Date.now();
  }
  /**
   * Shifts this line's position up by the specified offset.
   * Increases both the current position and removed position (if applicable) by the offset.
   * Used when lines are added to the document above this line.
   *
   * @param {number} offset - The number of lines to shift up (defaults to 1)
   */
  shiftUp(offset = 1) {
    if (this.existedInCurrent) {
      this.currentPosition += offset;
    }
    if (this.existedInOriginal && this.wasExplicitlyRemoved) {
      this.removedAtPosition += offset;
    }
  }
  /**
   * Shifts this line's position down by the specified offset.
   * Decreases both the current position and removed position (if applicable) by the offset.
   * Used when lines are removed from the document above this line.
   *
   * @param {number} offset - The number of lines to shift down (defaults to 1)
   */
  shiftDown(offset = 1) {
    if (this.existedInCurrent) {
      this.currentPosition -= offset;
    }
    if (this.existedInOriginal && this.wasExplicitlyRemoved) {
      this.removedAtPosition -= offset;
    }
  }
};

// src/maps/array.map.ts
var ArrayMap = class extends Map {
  /**
   * Creates an ArrayMap from an array of objects.
   * Uses either a property key or a function to determine the map keys.
   *
   * @template R - The type of objects in the input array
   * @template K - The key of R that has a string or number value
   * @param {Array} list - The array of objects to convert to an ArrayMap
   * @param {string|Function} key - Either a property name of R or a function that extracts a key from an R object
   * @return {ArrayMap} A new ArrayMap with the objects from the input array
   */
  static make(list, key2) {
    return new this(
      list.map((item) => [isFunction_default(key2) ? key2(item) : item[key2], item])
    );
  }
  /**
   * Converts the map values to a simple array.
   * Useful for performing array operations on the map values.
   *
   * @return {Array} An array containing all values from the map
   */
  simplify() {
    return [...this.values()];
  }
  /**
   * Finds the first element in the map that satisfies the provided testing function.
   * Converts the map to an array and uses Array.prototype.find.
   *
   * @param {Array} args - Arguments to pass to Array.prototype.find
   * @return {*} The first element that satisfies the testing function, or undefined if none is found
   */
  find(...args) {
    return this.simplify().find(...args);
  }
  /**
   * Executes a reducer function on each element of the map.
   * Converts the map to an array and uses Array.prototype.reduce.
   *
   * @param {Array} args - Arguments to pass to Array.prototype.reduce
   * @return {*} The value that results from running the reducer
   */
  reduce(...args) {
    return this.simplify().reduce(...args);
  }
  /**
   * Finds the index of the first element in the map that satisfies the provided testing function.
   * Converts the map to an array and uses Array.prototype.findIndex.
   *
   * @param {Array} args - Arguments to pass to Array.prototype.findIndex
   * @return {number} The index of the first element that satisfies the testing function, or -1 if none is found
   */
  findIndex(...args) {
    return this.simplify().findIndex(...args);
  }
  /**
   * Creates a new array with all elements from the map that pass the test implemented by the provided function.
   * Converts the map to an array and uses Array.prototype.filter.
   *
   * @param {Array} args - Arguments to pass to Array.prototype.filter
   * @return {Array} A new array with the elements that pass the test
   */
  filter(...args) {
    return this.simplify().filter(...args);
  }
};

// src/snapshots/file.snapshot.ts
var FileSnapshot = class {
  /**
   * Creates a new instance of FileSnapshot.
   * Initializes the snapshot with the provided content, splits it into lines,
   * creates tracker objects for each line, and saves the initial state.
   *
   * @param {string} content - The content of the file as a string
   * @param {string} lineBreak - The line break character used in the file (defaults to '\n')
   * @param {TFile | null} file - The Obsidian file object this snapshot belongs to
   */
  constructor(content, lineBreak, file) {
    // todo: make everything protected
    /**
     * Unique identifier for this snapshot.
     * Generated randomly when the snapshot is created.
     */
    this.id = TextHelper.rndId();
    /**
     * Original content of the file as an array of lines.
     * This represents the initial state of the file when the snapshot was created.
     */
    this.lines = [];
    /**
     * Timestamp when this snapshot was created.
     * Used for tracking when changes occurred.
     */
    this.timestamp = Date.now();
    /**
     * Map of line numbers to their corresponding change information.
     * Tracks what type of changes (added, modified, removed, restored) occurred at each line.
     */
    this.changes = new ArrayMap();
    /**
     * Array of tracker lines that maintain the history and state of each line.
     * Each TrackerLine object tracks a single line's original position, current position,
     * content, and change status.
     */
    this.tracker = [];
    /**
     * Hash of the last known state of the file.
     * Used to determine if the file has changed since the last update.
     */
    this.lastHash = null;
    /**
     * Current content of the file as an array of lines.
     * This represents the most recent state of the file.
     */
    this.state = [];
    /**
     * Line break character used in the file.
     * Defaults to '\n' but can be specified during construction.
     */
    this.lineBreak = "\n";
    var _a;
    if (lineBreak) {
      this.lineBreak = lineBreak;
    }
    if (file) {
      this.file = file;
    }
    this.lines = (_a = content == null ? void 0 : content.split(this.lineBreak)) != null ? _a : [];
    this.tracker = this.lines.map((line, index) => new TrackerLine({
      content: line,
      originalPosition: index,
      currentPosition: index,
      contentSameOriginal: true
    }));
    this.updateState(this.lines);
  }
  /**
   * Checks if the file content has changed since the last update.
   * Compares the hash of the provided content with the stored hash.
   *
   * @param {string} content - The current content of the file to check
   * @return {boolean} True if the content has changed and needs updating, false otherwise
   */
  isNeedUpdate(content) {
    return this.lastHash !== TextHelper.hash(content);
  }
  /**
   * Updates the current state of the file snapshot.
   * Stores the new content and updates the hash for future change detection.
   *
   * @param {string | string[]} content - The new content of the file, either as a string or array of lines
   */
  updateState(content) {
    this.state = isArray_default(content) ? [...content] : content.split(this.lineBreak);
    this.lastHash = TextHelper.hash(this.state.join(this.lineBreak));
  }
  /**
   * Checks if the current state is the same as the original state.
   * Compares the content of the file when the snapshot was created with its current content.
   *
   * @return {boolean} True if the current state matches the original state, false otherwise
   */
  isStateSameOriginal() {
    return this.getOriginalState() === this.getLastState();
  }
  /**
   * Gets the current state of the file as a string.
   * Joins the lines of the current state with the line break character.
   *
   * @return {string} The current state of the file as a string
   */
  getLastState() {
    return this.state.join(this.lineBreak);
  }
  /**
   * Gets the current state of the file as an array of lines.
   * Returns a copy of the state array to prevent direct modification.
   *
   * @return {string[]} The current state of the file as an array of lines
   */
  getLastStateLines() {
    return [...this.state];
  }
  /**
   * Gets the original state of the file as a string.
   * Joins the lines of the original state with the line break character.
   *
   * @return {string} The original state of the file as a string
   */
  getOriginalState() {
    return [...this.lines].join(this.lineBreak);
  }
  /**
   * Gets the original state of the file as an array of lines.
   * Returns a copy of the lines array to prevent direct modification.
   *
   * @return {string[]} The original state of the file as an array of lines
   */
  getOriginalStateLines() {
    return [...this.lines];
  }
  /**
   * Gets the changes for the specified change types.
   * If no type is specified, returns all changes.
   *
   * @param {ChangeType | ChangeType[]} type - Optional change type or array of change types to filter by
   * @return {ArrayMap<ChangeLine>} A map of line numbers to their corresponding change information
   */
  getChanges(type) {
    if (!this.changes) {
      this.changes = new ArrayMap();
    }
    if (type) {
      return ArrayMap.make(
        this.changes.filter((change) => change.has(type)).map((change) => new ChangeLine(change.getLine(), change.getTypes())),
        (item) => item.getLine()
      );
    }
    return this.changes;
  }
  /**
   * Gets the total count of lines that have been changed, added, or removed.
   * Used to display the number of changed lines in the status bar.
   *
   * @return {number} The number of lines with changes
   */
  getChangesLinesCount() {
    return this.getChanges(["changed" /* changed */, "added" /* added */, "removed" /* removed */]).size;
  }
  /**
   * Retrieves the last modified date and time as a localized string.
   *
   * @return {string} The date and time of the last change in a localized string format.
   */
  getLastChangedDateTime() {
    return new Date(this.timestamp).toLocaleString();
  }
  /**
   * Performs a self-test on the snapshot to verify its integrity.
   * Checks various aspects of the snapshot's state and returns diagnostic information.
   * Used for debugging purposes.
   *
   * @return {object} An object containing diagnostic information about the snapshot
   */
  selfTest() {
    return {
      equal: this.isStateSameOriginal(),
      // changesCountToState: this.getChanges().size <= this.getLastStateLines().length,
      tracker: this.getTracker().simplify(),
      trackerLinesToState: this.getLastStateLines().map((_value, index) => {
        return this.findCurrentLine(index);
      }),
      trackerLinesToOrigin: this.getOriginalStateLines().map((_value, index) => {
        return this.findOriginalLine(index, null, false);
      }),
      stateMissingLines: this.getLastStateLines().reduce((acc, _value, index) => {
        return !this.findCurrentLine(index) ? [...acc, index] : acc;
      }, []),
      originMissingLines: this.getOriginalStateLines().reduce((acc, _value, index) => {
        return !this.findOriginalLine(index, null, false) ? [...acc, index] : acc;
      }, []),
      trackerDuplicatesLines: Object.entries(
        this.getTracker().reduce((acc, value) => {
          var _a;
          return {
            ...acc,
            [value.currentPosition]: [...(_a = acc[value.currentPosition]) != null ? _a : [], value]
          };
        }, {})
      ).filter(([_line, trackers]) => trackers.length > 1),
      trackerChangedLines: this.getTracker().filter(
        (value, _index) => value.isStateChanged()
      ).length,
      trackerToRemovedLines: this.getTracker({ ordering: "removedTimeStamp" }).filter(
        (value, _index) => value.isStateRemoved()
      ).length,
      trackerToAddedLines: this.getTracker().filter(
        (value, _index) => value.isStateAdded()
      ).length,
      trackerToRestoredLines: this.getTracker().filter(
        (value, _index) => value.isStateRestored()
      ).length,
      trackerToGhostLines: this.getTracker().filter(
        (value, _index) => value.isStateGhost()
      ).length,
      changes: this.getChanges()
    };
  }
  /**
   * Updates the change map based on the current state of tracker lines.
   * Iterates through all tracker lines and adds appropriate change types
   * (added, removed, restored, changed) to the change map.
   */
  updateChanges() {
    const store = this.getChanges();
    store.clear();
    this.getTracker().forEach((lineTracker) => {
      var _a;
      if (!lineTracker || lineTracker.isStateGhost()) {
        return;
      }
      const position = lineTracker.isStateRemoved() ? lineTracker.removedAtPosition : lineTracker.currentPosition;
      const line = (_a = store.get(position)) != null ? _a : new ChangeLine(position, []);
      if (!store.has(position)) {
        store.set(position, line);
      }
      if (lineTracker.isStateRemoved()) {
        line.add("removed" /* removed */);
        return;
      }
      if (lineTracker.isStateAdded()) {
        line.add("added" /* added */);
        return;
      }
      if (lineTracker.isStateRestored()) {
        line.add("restored" /* restored */);
        return;
      }
      if (lineTracker.isStateChanged()) {
        line.add("changed" /* changed */);
        return;
      }
    });
  }
  /**
   * Finds a tracker line at the specified current position.
   * Searches for a tracker line that is currently at the given line number.
   *
   * @param {number} line - The line number to search for
   * @param {number} to - Optional upper bound for range checking
   * @return {TrackerLine | null} The tracker line at the specified position, or null if not found
   */
  findCurrentLine(line, to) {
    var _a;
    return (_a = this.getTracker().find(
      (tracker) => (
        // todo: possibly some checks are redundant
        tracker.isCurrentAt(line) && tracker.isCurrentInRange(0, to)
      )
    )) != null ? _a : null;
  }
  /**
   * Finds a tracker line originally at the specified position.
   * Can search for lines based on their original or current position.
   *
   * @param {number} line - The line number to search for
   * @param {number} to - Optional upper bound for range checking
   * @param {boolean} visible - If true, searches by current position; if false, by original position
   * @return {TrackerLine | null} The tracker line that was originally at the specified position, or null if not found
   */
  findOriginalLine(line, to, visible = true) {
    var _a;
    return (_a = this.getTracker().find(
      (tracker) => (
        // todo: possibly some checks are redundant
        (visible ? tracker.isCurrentAt(line) : tracker.isOriginAt(line)) && tracker.existedInOriginal && tracker.isOriginalInRange(0, to)
      )
    )) != null ? _a : null;
  }
  /**
   * Finds a tracker line removed at the specified position.
   * Searches for a tracker line that was removed at the given line number.
   *
   * @param {number} line - The line number where a line was removed
   * @return {TrackerLine | null} The tracker line that was removed at the specified position, or null if not found
   */
  findRemovedAt(line) {
    var _a;
    return (_a = this.getTracker({ ordering: ["removedTimeStamp", "dsc"] }).find(
      (tracker) => tracker.isStateRemovedAt(line)
    )) != null ? _a : null;
  }
  /**
   * Gets the tracker lines with optional sorting and key mapping.
   * Returns an ArrayMap of tracker lines that can be sorted and keyed as specified.
   *
   * @param {object} params - Optional parameters for sorting and keying the tracker lines
   * @param {string} params.keyBy - Property to use as the key in the returned ArrayMap
   * @param {Array|string} params.ordering - Property to sort by, or a tuple of property and direction
   * @return {ArrayMap<TrackerLine>} An ArrayMap of tracker lines
   */
  getTracker(params) {
    const {
      keyBy = "key",
      ordering = "key"
    } = params != null ? params : {};
    const sort = isArray_default(ordering) ? ordering[0] : ordering;
    const direction = isArray_default(ordering) ? ordering[1] : "acs";
    const list = [...this.tracker];
    list.sort((a, b) => {
      const va = a[sort];
      const vb = b[sort];
      switch (direction) {
        case "asc":
          if (isNumber_default(va) && isNumber_default(vb)) {
            return va - vb;
          }
          if (isString_default(va) && isString_default(vb)) {
            return va.localeCompare(vb);
          }
          break;
        case "dsc":
          if (isNumber_default(va) && isNumber_default(vb)) {
            return vb - va;
          }
          if (isString_default(va) && isString_default(vb)) {
            return vb.localeCompare(va);
          }
          break;
      }
    });
    return ArrayMap.make(list, keyBy);
  }
  /**
   * Moves a tracker line to a new position.
   * Shifts other lines as needed to accommodate the move.
   *
   * @param {number} line - The current line number of the tracker to move
   * @param {number} position - The new position to move the tracker to
   * @return {TrackerLine | null} The moved tracker line, or null if no tracker was found at the specified line
   */
  moveTo(line, position) {
    const tracker = this.findCurrentLine(line);
    if (!tracker) {
      return null;
    }
    if (tracker.isCurrentAt(position)) {
      return tracker;
    }
    if (tracker.isCurrentLT(position)) {
      this.shiftUp(line, tracker.getCurrentPositionOffset(position));
    }
    if (tracker.isCurrentGT(position)) {
      this.shiftDown(line, tracker.getCurrentPositionOffset(position));
    }
    tracker.moveTo(position);
    return tracker;
  }
  /**
   * Shifts tracker lines up by the specified offset.
   * Affects all tracker lines within the specified range.
   *
   * @param {number} line - The starting line number of the range to shift
   * @param {number} to - Optional ending line number of the range to shift
   * @param {number} offset - Optional number of lines to shift by (defaults to 1)
   * @return {Record<number, TrackerLine[]>} A record mapping line numbers to arrays of tracker lines at those positions
   */
  shiftUp(line, to, offset) {
    const positions = {};
    this.getTracker({ keyBy: "id" }).forEach((tracker) => {
      if (tracker.isCurrentInRange(line, to)) {
        tracker.shiftUp(offset);
        (positions[tracker.currentPosition] || (positions[tracker.currentPosition] = [])).push(tracker);
      }
    });
    return positions;
  }
  /**
   * Shifts removed tracker lines up by the specified offset.
   * Affects all removed tracker lines within the specified range.
   *
   * @param {number} line - The starting line number of the range to shift
   * @param {number} to - Optional ending line number of the range to shift
   * @param {number} offset - Optional number of lines to shift by (defaults to 1)
   * @return {Record<number, TrackerLine[]>} A record mapping line numbers to arrays of tracker lines at those positions
   */
  shiftUpRemoved(line, to, offset) {
    const positions = {};
    this.getTracker({ keyBy: "id" }).forEach((tracker) => {
      if (tracker.isRemoveInRange(line, to)) {
        tracker.shiftUp(offset);
        (positions[tracker.removedAtPosition] || (positions[tracker.removedAtPosition] = [])).push(tracker);
      }
    });
    return positions;
  }
  /**
   * Shifts tracker lines down by the specified offset.
   * Affects all tracker lines within the specified range.
   *
   * @param {number} line - The starting line number of the range to shift
   * @param {number} to - Optional ending line number of the range to shift
   * @param {number} offset - Optional number of lines to shift by (defaults to 1)
   * @return {Record<number, TrackerLine[]>} A record mapping line numbers to arrays of tracker lines at those positions
   */
  shiftDown(line, to, offset) {
    const positions = {};
    this.getTracker({ keyBy: "id" }).forEach((tracker) => {
      if (tracker.isCurrentInRange(line, to)) {
        tracker.shiftDown(offset);
        (positions[tracker.currentPosition] || (positions[tracker.currentPosition] = [])).push(tracker);
      }
    });
    return positions;
  }
  /**
   * Shifts removed tracker lines down by the specified offset.
   * Affects all removed tracker lines within the specified range.
   *
   * @param {number} line - The starting line number of the range to shift
   * @param {number} to - Optional ending line number of the range to shift
   * @param {number} offset - Optional number of lines to shift by (defaults to 1)
   * @return {Record<number, TrackerLine[]>} A record mapping line numbers to arrays of tracker lines at those positions
   */
  shiftDownRemoved(line, to, offset) {
    const positions = {};
    this.getTracker({ keyBy: "id" }).forEach((tracker) => {
      if (tracker.isRemoveInRange(line, to)) {
        tracker.shiftDown(offset);
        (positions[tracker.removedAtPosition] || (positions[tracker.removedAtPosition] = [])).push(tracker);
      }
    });
    return positions;
  }
  /**
   * Restores a removed tracker line or adds a new one at the specified position.
   * If a removed tracker line is found at the position, it is restored.
   * Otherwise, a new tracker line is added.
   *
   * @param {number | TrackerLine} line - The line number or tracker line to restore or add
   * @param {boolean} shift - Whether to shift other lines to accommodate the restored/added line
   * @return {TrackerLine} The restored or added tracker line
   */
  restoreOrAddTracker(line, shift = true) {
    const removed = line instanceof TrackerLine ? line : this.findRemovedAt(line);
    const index = line instanceof TrackerLine ? line.removedAtPosition : line;
    if (shift) {
      this.shiftUp(index);
    }
    if (removed) {
      removed.restore(index);
    }
    if (shift) {
      this.shiftUpRemoved(index);
    }
    return removed != null ? removed : this.addTrackerLine({ currentPosition: index });
  }
  /**
   * Removes a tracker line or marks it as removed.
   * If the line existed in the original state, it is marked as removed.
   * Otherwise, it is completely removed from the tracker array.
   *
   * @param {number | TrackerLine} line - The line number or tracker line to remove
   * @param {boolean} shift - Whether to shift other lines to accommodate the removed line
   * @return {TrackerLine | null} The removed tracker line, or null if no tracker was found
   */
  removeTrackerOrLine(line, shift = true) {
    const tracker = line instanceof TrackerLine ? line : this.findCurrentLine(line);
    const index = line instanceof TrackerLine ? line.currentPosition : line;
    const existedInOriginal = tracker == null ? void 0 : tracker.existedInOriginal;
    if (!tracker) {
      return null;
    }
    if (shift) {
      this.shiftDown(index + 1);
      this.shiftDownRemoved(index + 1);
    }
    if (existedInOriginal) {
      tracker.remove();
    } else {
      this.removeTrackerLine(tracker);
    }
    return tracker;
  }
  /**
   * Adds a new tracker line to the snapshot.
   * Creates a new TrackerLine instance with the provided parameters and adds it to the tracker array.
   *
   * @param {TrackerLineParams} params - Optional parameters for the new tracker line
   * @return {TrackerLine} The newly created tracker line
   */
  addTrackerLine(params) {
    const tracker = new TrackerLine(params);
    this.tracker.push(tracker);
    return tracker;
  }
  /**
   * Removes a tracker line from the snapshot.
   * Finds the tracker line by line number or reference and removes it from the tracker array.
   *
   * @param {number | TrackerLine} line - The line number or tracker line to remove
   */
  removeTrackerLine(line) {
    const index = this.tracker.findIndex(
      (tracker) => line instanceof TrackerLine ? tracker.isEq(line) : tracker.isCurrentAt(line)
    );
    if (index === -1) {
      return;
    }
    this.tracker.splice(index, 1);
  }
};

// src/services/snapshots.service.ts
var SnapshotsService = class {
  /**
   * Creates a new instance of SnapshotsService.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Map of file paths to their corresponding snapshots.
     * Uses ObservableMap to notify subscribers when snapshots change.
     */
    this.fileSnapshots = new ObservableMap();
    /**
     * Set of files to ignore when capturing snapshots.
     * Files in this list will not have any changes tracked.
     */
    this.ignoreList = /* @__PURE__ */ new Set();
  }
  /**
   * Initializes the service.
   * Sets up a subscription to emit an event when snapshots are updated.
   */
  async init() {
    this.fileSnapshots.subscribe(() => {
      this.plugin.emit("snapshots:update" /* snapshotsUpdate */);
    });
  }
  /**
   * Loads snapshots for all files in the workspace.
   * Called when the plugin is loaded.
   */
  async load() {
    for (const file of [...this.plugin.getWorkspaceFiles().values()]) {
      await this.capture(file);
    }
  }
  /**
   * Gets a snapshot for a specific file.
   * If no file is provided, use the active file.
   *
   * @param {TFile} file - The file to get the snapshot for, or null to use the active file
   * @return {FileSnapshot|null} The file snapshot, or null if no snapshot exists
   */
  getOne(file) {
    var _a;
    const currentFile = file != null ? file : this.plugin.getActiveFile();
    return (_a = this.fileSnapshots.get(currentFile == null ? void 0 : currentFile.path)) != null ? _a : null;
  }
  /**
   * Gets all snapshots.
   *
   * @return {FileSnapshot[]} An array of all file snapshots
   */
  getList() {
    return [...this.fileSnapshots.values()];
  }
  /**
   * Adds a new snapshot for the specified file.
   * Creates a FileSnapshot with the provided content and stores it in the map.
   *
   * @param {TFile} file - The file to create a snapshot for
   * @param {string} content - The content to snapshot
   */
  add(file, content) {
    var _a;
    if (!file) {
      return;
    }
    const lineBreak = (_a = this.plugin.getActiveEditorView()) == null ? void 0 : _a.state.lineBreak;
    this.fileSnapshots.set(
      file.path,
      new FileSnapshot(content, lineBreak, file)
    );
  }
  /**
   * Removes the snapshot for the specified file.
   *
   * @param {TFile} file - The file whose snapshot should be removed
   */
  remove(file) {
    if (!file) {
      return;
    }
    this.fileSnapshots.delete(file.path);
  }
  /**
   * Clears all snapshots from the service.
   * Removes all stored file snapshots.
   */
  clear() {
    this.fileSnapshots.clear();
  }
  /**
   * Forces an update of the snapshots.
   * Triggers the observable map to notify subscribers.
   *
   * @return {void}
   */
  forceUpdate() {
    return this.fileSnapshots.next("update");
  }
  /**
   * Adds a file to the ignore list.
   * Files in the ignore list will not have any changes tracked.
   *
   * @param {TFile} file - The file to add to the ignore list
   */
  addToIgnoreList(file) {
    if (!file) {
      return;
    }
    this.ignoreList.add(file);
  }
  /**
   * Removes a file from the ignore list.
   * The file will be eligible for change tracking again.
   *
   * @param {TFile} file - The file to remove from the ignore list
   */
  removeFromIgnoreList(file) {
    if (!file) {
      return;
    }
    this.ignoreList.delete(file);
  }
  /**
   * Checks if a file is in the ignore list.
   *
   * @param {TFile} file - The file to check
   * @return {boolean} True if the file is in the ignore list, false otherwise
   */
  isInIgnoreList(file) {
    if (!file) {
      return false;
    }
    return this.ignoreList.has(file);
  }
  /**
   * Clears all files from the ignore list.
   * All files will be eligible for change tracking again.
   */
  clearIgnoreList() {
    this.ignoreList.clear();
  }
  /**
   * Gets all files currently in the ignore list.
   *
   * @return {TFile[]} An array of files in the ignore list
   */
  getIgnoreList() {
    return [...this.ignoreList];
  }
  /**
   * Checks if a file is a plain text file based on its extension.
   * Accepts either a comma-separated string of extensions or an array of extensions.
   *
   * @param {TFile} file - The file to check
   * @return {boolean} True if the file is a plain text file, false otherwise
   */
  isInAllowedExtensions(file) {
    return this.settingsService.value("allowedExtensions").split(",").map((ext) => ext.trim().toLowerCase()).includes(file.extension.toLowerCase());
  }
  /**
   * Checks if a file has already been captured (has a snapshot).
   *
   * @param {TFile} file - The file to check
   * @return {boolean} True if the file has been captured, false otherwise
   */
  isCaptured(file) {
    if (!file) {
      return false;
    }
    return this.fileSnapshots.has(file.path);
  }
  /**
   * Determines if a file can be captured for change tracking.
   * A file can be captured if it has an allowed extension, hasn't been captured yet,
   * and is not in the ignore list.
   *
   * @param {TFile} file - The file to check
   * @return {boolean} True if the file can be captured, false otherwise
   */
  canCapture(file) {
    if (!file) {
      return false;
    }
    const isExtensionAllowed = this.isInAllowedExtensions(file);
    const isHasInList = this.isCaptured(file);
    const isIgnored = this.isInIgnoreList(file);
    return isExtensionAllowed && !isHasInList && !isIgnored;
  }
  /**
   * Creates a snapshot for a file.
   * If no file is provided, use the active file.
   * Only captures files that match the configured extensions and don't already have a snapshot.
   *
   * @param {TFile} file - The file to capture, or null to use the active file
   */
  async capture(file) {
    const currentFile = file != null ? file : this.plugin.getActiveFile();
    if (!this.canCapture(currentFile)) {
      return;
    }
    try {
      const content = await this.plugin.app.vault.read(currentFile);
      this.add(currentFile, content);
    } catch (error) {
      console.error("Error capturing file snapshot:", error);
    }
  }
  /**
   * Removes a snapshot for a specific file.
   * If no file is provided, use the active file.
   * Forces an editor update and recaptures the file if it's the active file.
   *
   * @param {TFile} file - The file to remove the snapshot for, or null to use the active file
   */
  wipeOne(file) {
    const current = this.plugin.getActiveFile();
    this.remove(file != null ? file : current);
    this.removeFromIgnoreList(file != null ? file : current);
    if (this.plugin.getActiveViewOfType()) {
      this.plugin.forceUpdateEditor();
    }
    if (current && (!file || (file == null ? void 0 : file.path) === current.path)) {
      void this.capture();
    }
  }
  /**
   * Removes all snapshots.
   * Forces an editor update and captures the active file.
   */
  wipe() {
    this.clear();
    this.clearIgnoreList();
    if (this.plugin.getActiveViewOfType()) {
      this.plugin.forceUpdateEditor();
    }
    void this.capture();
  }
};
__decorateClass([
  Inject("SettingsService")
], SnapshotsService.prototype, "settingsService", 2);

// src/decorators/on.decorator.ts
var On = (name) => {
  return (target, propertyKey) => {
    return Reflect.defineMetadata("ON_EVENT", { name }, target, propertyKey);
  };
};

// src/services/statusbar.service.ts
var import_obsidian9 = require("obsidian");
var StatusbarService = class {
  /**
   * Creates a new instance of StatusbarService.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Map of status bar item IDs to their corresponding HTML elements.
     * Used to track and manage status bar items.
     */
    this.items = /* @__PURE__ */ new Map();
  }
  /**
   * Initializes the service by creating a status bar item.
   * Creates a clickable status bar item that opens the diff modal when clicked.
   * Called during plugin initialization.
   */
  init() {
    this.add({
      clickable: true,
      onClick: () => {
        this.modalService.diff();
      }
    });
  }
  updateFileStatus() {
    var _a, _b;
    const view = (_a = this.plugin.app.workspace.getMostRecentLeaf()) == null ? void 0 : _a.view;
    const snapshot = this.snapshotsService.getOne();
    if (!view || !(view instanceof import_obsidian9.MarkdownView) || !snapshot) {
      this.clear();
      return;
    }
    this.update(`${(_b = snapshot.getChangesLinesCount()) != null ? _b : 0} lines changed`);
  }
  /**
   * Clears a status bar item by hiding it and removing its text.
   * If no ID is provided, use the default status bar item ID.
   *
   * @param {string} id - The ID of the status bar item to clear, or undefined to use the default
   */
  clear(id) {
    const item = this.get(id);
    if (!item) {
      return;
    }
    item.hide();
    item.setText("");
  }
  /**
   * Updates the text of a status bar item and makes it visible.
   * If no ID is provided, use the default status bar item ID.
   *
   * @param {string} title - The text to display in the status bar item
   * @param {string} id - The ID of the status bar item to update, or undefined to use the default
   */
  update(title, id) {
    const item = this.get(id);
    if (!item) {
      return;
    }
    item.setText(title);
    item.show();
  }
  /**
   * Gets a status bar item by its ID.
   * If no ID is provided, use the default status bar item ID.
   *
   * @param {string} id - The ID of the status bar item to get, or undefined to use the default
   * @return {HTMLElement|null} The HTML element for the status bar item, or null if not found
   */
  get(id) {
    var _a;
    return (_a = this.items.get(id || STATUSBAR_ITEM_ID)) != null ? _a : null;
  }
  /**
   * Adds a new status bar item to the Obsidian interface.
   * If an item with the same ID already exists, returns the existing item.
   * Configure the item with optional click behavior and styling.
   *
   * @param {StatusBarItemCreate} options - Configuration options for the status bar item
   * @return {HTMLElement} The HTML element for the status bar item
   */
  add(options) {
    const id = (options == null ? void 0 : options.id) || STATUSBAR_ITEM_ID;
    const exists = this.items.get(id);
    if (exists) {
      return exists;
    }
    const item = this.plugin.addStatusBarItem();
    this.items.set(id, item);
    if (options == null ? void 0 : options.clickable) {
      item.addClass("mod-clickable");
    }
    if (options == null ? void 0 : options.onClick) {
      item.onClickEvent(
        function(event) {
          options.onClick(this, event);
        },
        options.onClickOptions || false
      );
    }
    return item;
  }
};
__decorateClass([
  Inject("ModalsService")
], StatusbarService.prototype, "modalService", 2);
__decorateClass([
  Inject("SnapshotsService")
], StatusbarService.prototype, "snapshotsService", 2);
__decorateClass([
  On("snapshots:update" /* snapshotsUpdate */)
], StatusbarService.prototype, "updateFileStatus", 1);

// src/services/styles.service.ts
var StylesService = class {
  /**
   * Creates a new instance of StylesService.
   *
   * @param {LineChangeTrackerPlugin} plugin - The plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Initializes the service by creating a style tag.
   * Called during plugin initialization.
   */
  init() {
    this.createStyleTag();
  }
  /**
   * Loads the service by updating the CSS styles.
   * Called after initialization to apply initial styles.
   */
  load() {
    this.update();
  }
  update() {
    const width = this.settingsService.value("line.width");
    this.sheet.setText(`
        .lct {
          --lct-color-${"changed" /* changed */}: var(--color-blue);
          --lct-color-${"restored" /* restored */}: var(--text-faint);
          --lct-color-${"added" /* added */}: var(--color-orange);
          --lct-color-${"removed" /* removed */}: var(--color-base-100);
          --lct-line-width: ${width}px;
          --lct-line-border-radius: ${(width / 2).toFixed(0)}px;
        }
    `);
  }
  /**
   * Unloads the service by removing the style element from the DOM.
   * Called when the plugin is disabled or unloaded.
   * Performs a safety check to ensure the sheet exists before attempting removal.
   */
  unload() {
    if (!this.sheet) {
      return;
    }
    this.sheet.remove();
  }
  /**
   * Creates a style tag in the document head.
   * Either finds an existing style element with the plugin's style ID or creates a new one.
   * Sets appropriate attributes and appends it to the document head if needed.
   * Assigns the created/found element to the sheet property for later use.
   */
  createStyleTag() {
    const styleSheet = document.getElementById(STYLE_ID) || document.createElement("style");
    styleSheet.setAttribute("type", "text/css");
    styleSheet.setAttribute("id", STYLE_ID);
    if (!styleSheet.parentElement) {
      document.head.appendChild(styleSheet);
    }
    this.sheet = styleSheet;
  }
};
__decorateClass([
  Inject("SettingsService")
], StylesService.prototype, "settingsService", 2);
__decorateClass([
  On("settings:update" /* settingsUpdate */)
], StylesService.prototype, "update", 1);

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// src/main.ts
var import_obsidian10 = require("obsidian");
var LineChangeTrackerPlugin = class extends import_obsidian10.Plugin {
  /**
   * Creates a new instance of the LineChangeTrackerPlugin.
   * Registers all required services during initialization.
   *
   * @param {App} app - The Obsidian app instance
   * @param {PluginManifest} manifest - The plugin manifest
   */
  constructor(app, manifest) {
    super(app, manifest);
    /**
     * Event emitter used for internal plugin communication.
     * Services can subscribe to events and emit events to communicate with each other.
     */
    this.emitter = new eventemitter3_default();
    /**
     * Container for all registered services.
     * Maps service class constructors to their instances.
     */
    this.container = /* @__PURE__ */ new Map();
    this.registerService(SettingsService);
    this.registerService(StylesService);
    this.registerService(ModalsService);
    this.registerService(ExtensionsService);
    this.registerService(StatusbarService);
    this.registerService(CommandsService);
    this.registerService(EventsService);
    this.registerService(SnapshotsService);
  }
  /**
   * Registers a service with the plugin.
   * Creates an instance of the service, stores it in the container,
   * and sets up event listeners for methods decorated with @On.
   *
   * @template T - The service type
   * @param {ClassConstructor<T>} provider - The service class constructor
   */
  registerService(provider) {
    const inst = new provider(this);
    this.container.set(provider, inst);
    for (const prop of Object.getOwnPropertyNames(Object.getPrototypeOf(inst))) {
      const event = Reflect.getMetadata("ON_EVENT", inst, prop);
      const inject = Reflect.getMetadata("INJECT", inst, prop);
      if (!inject && event && prop in inst) {
        const method = inst[prop];
        if (isFunction_default(method)) {
          this.emitter.on(event.name, method, inst);
        }
      }
    }
  }
  /**
   * Retrieves a service from the container.
   * Can look up services by class constructor or by class name.
   *
   * @template T - The service type
   * @param {ClassConstructor<T> | string} key - The service class constructor or class name
   * @return {T} The service instance
   * @throws Error if the service is not registered
   */
  get(key2) {
    if (!key2) {
      throw new Error("Service cannot be empty");
    }
    const type = isString_default(key2) ? [...this.container.keys()].find((item) => item.name === key2) : key2;
    const service = this.container.get(type);
    if (!service) {
      throw new Error(`Service '${type.name}' not registered`);
    }
    return service;
  }
  /**
   * Lifecycle method called when the plugin is loaded.
   * Initializes and loads all registered services.
   *
   * @return {Promise<void>} A promise that resolves when all services are loaded
   */
  async onload() {
    await this.exec("init");
    await this.exec("load");
  }
  /**
   * Lifecycle method called when the plugin is unloaded.
   * Unloads all registered services.
   *
   * @return {Promise<void>} A promise that resolves when all services are unloaded
   */
  onunload() {
    return this.exec("unload");
  }
  /**
   * Executes a method on all registered services.
   * Used for lifecycle management (init, load, unload).
   *
   * @param {string} method - The method name to execute on each service
   * @return {Promise<void>} A promise that resolves when all method executions are complete
   */
  async exec(method) {
    for (const provider of [...this.container.values()]) {
      if (method in provider && isFunction_default(provider[method])) {
        await provider[method]();
      }
    }
  }
  /**
   * Emits an event with the given name and payload.
   *
   * @param {string} name - The name of the event to emit
   * @param {unknown[]} payload - Additional data to pass with the event
   * @return {boolean} True if the event had listeners, false otherwise
   */
  emit(name, ...payload) {
    return this.emitter.emit(name, payload);
  }
  /**
   * Registers an event listener for the specified event.
   *
   * @param {string} name - The name of the event to listen for
   * @param {Function} fn - The callback function to execute when the event is emitted
   * @param {unknown} context - The context to bind the callback function to
   * @return {EventEmitter<string | symbol, unknown>} The event emitter instance for chaining
   */
  on(name, fn, context) {
    return this.emitter.on(name, fn, context);
  }
  /**
   * Removes an event listener for the specified event.
   *
   * @param {string} name - The name of the event to remove the listener from
   * @param {Function} fn - The callback function to remove
   * @param {unknown} context - The context that was used when the listener was added
   * @return {EventEmitter<string | symbol, unknown>} The event emitter instance for chaining
   */
  off(name, fn, context) {
    return this.emitter.off(name, fn, context);
  }
  /**
   * Forces an update of the current editor view.
   * Dispatches an empty transaction to trigger a refresh.
   */
  forceUpdateEditor() {
    var _a;
    (_a = this.getResentEditorView()) == null ? void 0 : _a.dispatch({
      effects: [],
      changes: []
    });
  }
  /**
   * Gets the active editor view.
   *
   * @return {EditorView | null} The active CodeMirror editor view, or null if none is active
   */
  getActiveEditorView() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.getActiveViewOfType()) == null ? void 0 : _a.editor) == null ? void 0 : _b.cm) != null ? _c : null;
  }
  /**
   * Gets the most recently used editor view.
   *
   * @return {EditorView | null} The most recent CodeMirror editor view, or null if none exists
   */
  getResentEditorView() {
    var _a, _b;
    const view = this.app.workspace.getMostRecentLeaf().view;
    return (_b = (_a = view == null ? void 0 : view.editor) == null ? void 0 : _a.cm) != null ? _b : null;
  }
  /**
   * Gets the active Markdown view.
   *
   * @return {MarkdownView | null} The active markdown view, or null if none is active
   */
  getActiveViewOfType() {
    return this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
  }
  /**
   * Gets the active file.
   *
   * @return {TFile | null} The active file, or null if none is active
   */
  getActiveFile() {
    return this.app.workspace.getActiveFile();
  }
  /**
   * Gets all Markdown files currently open in the workspace.
   *
   * @return {Set<TFile>} A set of all open Markdown files
   */
  getWorkspaceFiles() {
    return new Set(
      this.app.workspace.getLeavesOfType("markdown").map((leaf) => {
        var _a;
        return (_a = leaf.view) == null ? void 0 : _a.file;
      })
    );
  }
};
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
